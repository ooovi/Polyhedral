/-
Copyright (c) 2025 Justus Springer, Martin Winter. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Justus Springer, Martin Winter
-/
import Mathlib.LinearAlgebra.Dual.Defs
import Mathlib.LinearAlgebra.PerfectPairing.Basic
import Mathlib.RingTheory.Finiteness.Basic
import Mathlib.LinearAlgebra.SesquilinearForm.Basic

import Polyhedral.Mathlib.Geometry.Convex.Cone.Pointed._CoFG

/-!
# Polyhedral cones

Given a bilinear pairing `p` between two `R`-modules `M` and `N`, we define
polyhedral cones to be pointed cones in `N` that are the dual of a finite set
in `M` (this means they are the intersection of finitely many halfspaces).

The main statement is that if both `M` and `N` are finite and the pairing is injective
in both arguments, then polyhedral cones are precisely the finitely generated cones, see
`isPolyhedral_iff_fg`. Moreover, we obtain that the dual of a polyhedral cone is again polyhedral
(`IsPolyhedral.dual`) and that the double dual of a polyhedral cone is the cone itself
(`IsPolyhedral.dual_dual_flip`, `IsPolyhedral.dual_flip_dual`).
-/

open Function Module LinearMap
open Submodule hiding span dual

variable {ğ•œ M N : Type*}

namespace PointedCone

alias sup_fg := Submodule.FG.sup

section LinearOrder

variable [Field ğ•œ] [LinearOrder ğ•œ] [IsStrictOrderedRing ğ•œ] [AddCommGroup M] [AddCommGroup N]
  [Module ğ•œ M] [Module ğ•œ N] {p : M â†’â‚—[ğ•œ] N â†’â‚—[ğ•œ] ğ•œ} {C : PointedCone ğ•œ M} {s : Set M} {w : N}

variable (p s w) in
/-- A set whose dual cone is `span R {w} âŠ” dual p s`, see `dual_sup_span_singleton_eq_dual` -/
private noncomputable abbrev auxGenSet : Set M :=
  {x âˆˆ s | 0 â‰¤ p x w} âˆª
    .image2 (fun x y â†¦ p x w â€¢ y - p y w â€¢ x) {x âˆˆ s | 0 â‰¤ p x w} {y âˆˆ s | p y w < 0}

variable (w) in
omit [IsStrictOrderedRing ğ•œ] in
private lemma auxGenSet_finite (hs : s.Finite) :
    (auxGenSet p s w).Finite := .union (hs.sep _) <| .image2 _ (hs.sep _) (hs.sep _)

private lemma auxGenSet_subset_span :
    (auxGenSet p s w : Set M) âŠ† span ğ•œ (s : Set M) := by
  simp only [Set.union_subset_iff, Set.image2_subset_iff, Set.mem_setOf_eq, and_imp]
  refine âŸ¨subset_trans (fun x hx â†¦ hx.1) subset_span, fun x hxS hxw y hyS hyw â†¦ ?_âŸ©
  -- simpa [sub_eq_add_neg] using add_mem (smul_mem (span ğ•œ s) âŸ¨p x w, hxwâŸ© (subset_span hyS))
  --   (smul_mem _ âŸ¨-p y w, neg_nonneg.mpr hyw.leâŸ© (subset_span hxS))
  sorry -- code broke on mathlib/Lean update ?

private lemma span_singleton_le_dual_auxGenSet :
    span ğ•œ {w} â‰¤ dual p (auxGenSet p s w) := by
  simp only [span_singleton_le_iff_mem, mem_dual, Set.mem_union, Set.mem_setOf_eq, Set.mem_image2]
  rintro z (hz | âŸ¨x, âŸ¨hxS, hxwâŸ©, y, âŸ¨hyS, hywâŸ©, rflâŸ©)
  Â· exact hz.2
  Â· simp only [map_sub, map_smul, LinearMap.sub_apply, LinearMap.smul_apply, smul_eq_mul,
      sub_nonneg]
    rw [mul_comm]

/-- The crucial lemma in the proof that a finitely generated cone is polyhedral:
The sum of a polyhedral cone and the cone generated by a single ray is again polyhedral. -/
private lemma dual_auxGenSet (hs : s.Finite) :
    dual p (auxGenSet p s w) = span ğ•œ {w} âŠ” dual p s := by
  classical
  apply ge_antisymm
  Â· rw [â† dual_span]
    exact sup_le span_singleton_le_dual_auxGenSet <| dual_le_dual auxGenSet_subset_span
  obtain hSw | hSw := {y âˆˆ s | p y w < 0}.eq_empty_or_nonempty
  Â· simp only [Set.sep_eq_empty_iff_mem_false, not_lt] at hSw
    exact le_sup_of_le_right <| dual_le_dual fun x hx => .inl âŸ¨hx, hSw _ hxâŸ©
  rw [dual_union]
  intro v âŸ¨hv1, hv2âŸ©
  rw [Submodule.mem_sup]
  replace hv2 {x y : M} (hx : x âˆˆ s âˆ§ 0 â‰¤ p x w) (hy : y âˆˆ s âˆ§ p y w < 0) :
      p y w * p x v â‰¤ p y v * p x w := by
    simp only [SetLike.mem_coe, mem_dual, Set.mem_image2, Set.mem_setOf_eq,
      forall_exists_index, and_imp] at hv2
    specialize hv2 x hx.1 hx.2 y hy.1 hy.2 rfl
    simp only [map_sub, map_smul, LinearMap.sub_apply, LinearMap.smul_apply, smul_eq_mul,
      sub_nonneg] at hv2
    nth_rw 2 [mul_comm] at hv2
    exact hv2
  obtain hSv | âŸ¨y, hyâŸ© := {y âˆˆ s | p y w < 0 âˆ§ p y v < 0}.eq_empty_or_nonempty
  Â· simp +contextual only [Set.sep_and, Set.eq_empty_iff_forall_notMem, Set.mem_inter_iff,
      Set.mem_setOf_eq, not_and, true_and, not_lt, and_imp] at hSv
    refine âŸ¨0, zero_mem _, v, fun x hx => ?_, zero_add _âŸ©
    by_cases hxw : 0 â‰¤ p x w
    Â· exact hv1 âŸ¨hx, hxwâŸ©
    Â· exact hSv x hx (lt_of_not_ge hxw)
  lift s to Finset M using hs
  let u : ğ•œ := ({y âˆˆ s | p y w < 0}.image (fun y => p y v * (p y w)â»Â¹)).max' <| by
    simpa [Finset.Nonempty, Set.Nonempty] using hSw.image _
  have hu : 0 â‰¤ u := by
    refine le_trans (mul_nonneg_of_nonpos_of_nonpos hy.2.2.le (inv_nonpos.mpr hy.2.1.le))
      (Finset.le_max' _ (p y v * (p y w)â»Â¹) ?_)
    simp only [Finset.mem_image, Finset.mem_filter]
    exact âŸ¨y, âŸ¨hy.1, hy.2.1âŸ©, rflâŸ©
  refine âŸ¨u â€¢ w, ?_, v - u â€¢ w, fun z hzS â†¦ ?_, add_sub_cancel _ _âŸ©
  Â· rw [â† Nonneg.mk_smul _ hu]
    exact Submodule.smul_mem _ _ (Submodule.subset_span rfl)
  simp only [map_sub, map_smul, smul_eq_mul, sub_nonneg]
  obtain hzw | hzw := lt_or_ge (p z w) 0
  Â· rw [â† _root_.mul_le_mul_right_of_neg (inv_neg''.mpr hzw), mul_inv_cancel_rightâ‚€ hzw.ne]
    exact Finset.le_max' _ (p z v * (p z w)â»Â¹) <|
      Finset.mem_image.mpr âŸ¨z, Finset.mem_filter.mpr âŸ¨hzS, hzwâŸ©, rflâŸ©
  obtain âŸ¨y, hy, t_eq : _ = uâŸ© := Finset.mem_image.mp <|
    ({y âˆˆ s | p y w < 0}.image (fun y => p y v * (p y w)â»Â¹)).max'_mem <| by
      simpa [Finset.Nonempty, Set.Nonempty] using hSw.image _
  rw [Finset.mem_filter] at hy
  rw [â† t_eq, â† _root_.mul_le_mul_left_of_neg hy.2, â† mul_assoc]
  nth_rw 4 [mul_comm]
  rw [mul_inv_cancel_leftâ‚€ hy.2.ne]
  exact hv2 âŸ¨hzS, hzwâŸ© hy

variable {p : M â†’â‚—[ğ•œ] N â†’â‚—[ğ•œ] ğ•œ}

/-- The union of an FG cone and a CoFG cone is CoFG. -/
lemma sup_fg_cofg {C D : PointedCone ğ•œ N} (hC : C.FG) (hD : D.CoFG p) : (C âŠ” D).CoFG p
    := by classical
  obtain âŸ¨s, rflâŸ© := hC
  induction s using Finset.induction with
  | empty => simp [hD]
  | insert w s hws hs =>
    obtain âŸ¨t, htâŸ© := hs
    use (auxGenSet p t.toSet w).toFinset
    simp [span_insert, sup_assoc, â† ht]
    exact dual_auxGenSet t.finite_toSet

variable (p) [Fact p.IsFaithfulPair] in
/-- An FG cone can be written as the intersection of a CoFG cone and an FG submodule. -/
lemma FG.exists_cofg_inf_submodule {C : PointedCone ğ•œ N} (hC : C.FG)
    {S : Submodule ğ•œ N} (hS : S.FG) (hCS : C â‰¤ S) :
      âˆƒ D : PointedCone ğ•œ N, D.CoFG p âˆ§ D âŠ“ S = C := by
  wlog hC' : C = âŠ¥ with h
  Â· specialize h p fg_bot hS bot_le rfl
    obtain âŸ¨D, hcofg, hDâŸ© := h
    exact âŸ¨_, sup_fg_cofg hC hcofg, by simp [â† sup_inf_assoc_of_le_submodule D hCS, hD]âŸ©
  Â· obtain âŸ¨D, hcofg, hDâŸ© := hS.exists_cofg_inf_bot p
    exact âŸ¨_, (coe_cofg p).mpr hcofg, by simp [â† restrictScalars_inf, inf_comm, hD, hC']âŸ©

variable (p) [Fact p.IsFaithfulPair] in
/-- An FG cone can be written as the intersection of its linear span with a CoFG cone. -/
lemma FG.exists_cofg_sup_span {C : PointedCone ğ•œ N} (hC : C.FG) :
      âˆƒ D : PointedCone ğ•œ N, D.CoFG p âˆ§ D âŠ“ Submodule.span ğ•œ (M := N) C = C :=
  exists_cofg_inf_submodule p hC (Submodule.span_scalars_FG hC) Submodule.subset_span

variable (p) [Fact p.IsFaithfulPair] in
/-- An FG cone can be written as the intersection of a CoFG cone and an FG submodule. -/
lemma FG.exists_cofg_sup_fg_submodule {C : PointedCone ğ•œ N} (hC : C.FG) :
      âˆƒ D : PointedCone ğ•œ N, D.CoFG p âˆ§ âˆƒ S : Subspace ğ•œ N, S.FG âˆ§ D âŠ“ S = C := by
  obtain âŸ¨D, hcofg, hDâŸ© := exists_cofg_sup_span p hC
  exact âŸ¨D, hcofg, Submodule.span ğ•œ C, submodule_span_fg hC, hDâŸ©

variable (p) [Fact p.IsFaithfulPair] in
/-- An FG cone is the dual of a CoFG cone. -/
lemma FG.exists_cofg_flip_dual {C : PointedCone ğ•œ N} (hC : C.FG) :
    âˆƒ D : PointedCone ğ•œ M, D.CoFG p.flip âˆ§ dual p D = C := by
  obtain âŸ¨D, hD, S, hS, rflâŸ© := exists_cofg_sup_fg_submodule p hC
  obtain âŸ¨C', hfg, rflâŸ© := hD.exists_fg_dual
  use C' âŠ” dual p.flip S
  constructor
  Â· exact sup_fg_cofg hfg <| cofg_of_fg p.flip (ofSubmodule_fg_of_fg hS)
  Â· simp [dual_sup_dual_inf_dual, Submodule.fg_dual_flip_dual hS]
    -- TODO: prove `Submodule.fg_dual_dual_flip` (the equivalent for cones was already proven here).

variable (p) [Fact p.flip.IsFaithfulPair] in
/-- An FG cone is the dual of a CoFG cone. -/
lemma FG.exists_cofg_dual_flip {C : PointedCone ğ•œ M} (hC : C.FG) :
    âˆƒ D : PointedCone ğ•œ N, D.CoFG p âˆ§ dual p.flip D = C := by
  rw [â† flip_flip p]; exact exists_cofg_flip_dual p.flip hC

variable (p) [Fact p.IsFaithfulPair] in
/-- The double dual of an FG cone is the cone itself. -/
@[simp]
lemma FG.fg_dual_dual_flip {C : PointedCone ğ•œ N} (hC : C.FG) : dual p (dual p.flip C) = C := by
  obtain âŸ¨D, hcofg, rflâŸ© := exists_cofg_flip_dual p hC
  exact dual_dual_flip_dual (p := p) D

variable (p) [Fact p.flip.IsFaithfulPair] in
/-- The double dual of an FG cone is the cone itself. -/
@[simp]
lemma FG.fg_dual_flip_dual {C : PointedCone ğ•œ M} (hC : C.FG) : dual p.flip (dual p C) = C := by
  rw [â† flip_flip p]; exact fg_dual_dual_flip p.flip hC

variable [Fact p.IsFaithfulPair] in
/-- The dual of a CoFG cone is FG. -/
lemma CoFG.dual_fg {C : PointedCone ğ•œ M} (hC : C.CoFG p.flip) : (dual p C).FG := by
  obtain âŸ¨D, hfg, rflâŸ© := exists_fg_dual hC
  rw [FG.fg_dual_dual_flip p hfg]
  exact hfg

variable [Fact p.flip.IsFaithfulPair] in
/-- The dual of a CoFG cone is FG. -/
lemma CoFG.dual_flip_fg {C : PointedCone ğ•œ N} (hC : C.CoFG p) : (dual p.flip C).FG := by
  rw [â† flip_flip p] at hC; exact dual_fg hC

-- ----------------- ^^^^^^^ everything up there is proven vvvvv down there is work

section Module.Finite

/- TODO: it is likely that in this section a lot of the assumptions (in terms of Module.Finite and
  IsFaithfulPair) can be reduced because it can be inferred from others. -/

variable [Module.Finite ğ•œ N] in
variable (p) [Fact p.IsFaithfulPair] in
/-- A finite dimensional FG cone is also CoFG. -/
lemma FG.cofg {C : PointedCone ğ•œ N} (hC : C.FG) : C.CoFG p := by
  obtain âŸ¨D, hcofg, rflâŸ© := exists_cofg_inf_submodule p hC Finite.fg_top (by simp)
  simpa using hcofg

  -- the two faithfuls should imply each other; maybe are even equivalent to `IsPerfPair` in findim.
variable [Module.Finite ğ•œ M] in
variable [Fact p.IsFaithfulPair] [Fact p.flip.IsFaithfulPair] in
/-- A finite dimensional CoFG cone is also FG. -/
lemma CoFG.fg {C : PointedCone ğ•œ N} (hC : C.CoFG p) : C.FG := by
  obtain âŸ¨D, hfg, rflâŸ© := hC.exists_fg_dual
  exact CoFG.dual_fg <| FG.cofg p.flip hfg

variable [Module.Finite ğ•œ M] [Module.Finite ğ•œ N] in
variable [Fact p.IsFaithfulPair] [Fact p.flip.IsFaithfulPair] in
/-- A finite dimensional cone is FG if and only if it is CoFG. -/
lemma fg_iff_cofg {C : PointedCone ğ•œ N} : C.CoFG p â†” C.FG := âŸ¨CoFG.fg, FG.cofg pâŸ©

variable [Module.Finite ğ•œ M] in
variable [Fact p.IsFaithfulPair] [Fact p.flip.IsFaithfulPair] in
/-- In finite dimensional space, the dual of and FG cone is itself FG. -/
lemma FG.dual_fg {C : PointedCone ğ•œ M} (hC : C.FG) : (dual p C).FG
  := CoFG.dual_fg (FG.cofg p.flip hC)

variable [Module.Finite ğ•œ M] in
variable [Fact p.IsFaithfulPair] [Fact p.flip.IsFaithfulPair] in
/-- In finite dimensional space, the dual of and CoFG cone is itself CoFG. -/
lemma CoFG.dual_cofg {C : PointedCone ğ•œ N} (hC : C.CoFG p) : (dual p.flip C).CoFG p.flip
  := FG.dual_cofg p.flip (CoFG.fg hC)

variable [Module.Finite ğ•œ M] in
private lemma inf_fg' {C D : PointedCone ğ•œ M} (hC : C.FG) (hD : D.FG) : (C âŠ“ D).FG := by
  exact CoFG.fg <| inf_cofg .id (FG.cofg .id hC) (FG.cofg .id hD)

variable [Module.Finite ğ•œ M] in
variable [Fact p.flip.IsFaithfulPair] in
private lemma FG.restrict_fg' (S : Submodule ğ•œ M) {C : PointedCone ğ•œ M} (hC : C.FG) :
    (C.restrict S).FG := by
  wlog hle : C â‰¤ S with h
  Â· let C' := C âŠ“ S
    have hS : S.FG := IsNoetherian.noetherian S
    have hfg : C'.FG := inf_fg' hC (restrictedScalars_fg_of_fg _ hS)
    have h' : C' â‰¤ S := by sorry
    -- specialize h hC h'
    sorry
  Â· sorry

variable [Module.Finite ğ•œ M] in
variable [Fact p.flip.IsFaithfulPair] in
private lemma FG.dual_inf_dual_sup_dual' {C D : PointedCone ğ•œ M} (hC : C.FG) (hD : D.FG) :
    dual p (C âŠ“ D) = (dual p C) âŠ” (dual p D) := by
  obtain âŸ¨C', hCfg', rflâŸ© := FG.exists_cofg_dual_flip p hC
  obtain âŸ¨D', hDfg', rflâŸ© := FG.exists_cofg_dual_flip p hD
  simp only [Set.inf_eq_inter, â† coe_inf, â† dual_union, â† dual_sup]
  sorry -- exact CoFG.fg <| inf_cofg .id (FG.cofg .id hC) (FG.cofg .id hD)

end Module.Finite

/- WARNING: `FG.restrict_fg` is used below, but is currently unproven and needs to be proven
  in this section! -/

lemma FG.restrict_fg'' (S : Submodule ğ•œ M) {C : PointedCone ğ•œ M} (hC : C.FG) (hSC : C â‰¤ S) :
    (C.restrict S).FG := by
  sorry

lemma FG.restrict_fg (S : Submodule ğ•œ M) {C : PointedCone ğ•œ M} (hC : C.FG) :
    (C.restrict S).FG := by
  sorry

/-- The intersection of two FG cones is an FG cone. -/
lemma inf_fg {C D : PointedCone ğ•œ N} (hC : C.FG) (hD : D.FG) : (C âŠ“ D).FG := by
  wlog _ : Module.Finite ğ•œ N with h
  Â· let CD := Submodule.span ğ•œ (M := N) (C âŠ” D)
    specialize h (FG.restrict_fg CD hC) (FG.restrict_fg CD hD) (Finite.iff_fg.mpr ?_)
    Â· simp only [CD, coe_sup_submodule_span]
      exact span_fg <| sup_fg hC hD
    Â· rw [â† restrict_inf] at h
      refine FG.fg_of_restrict ?_ h
      simp only [CD, coe_sup_submodule_span]
      exact le_trans (le_trans (inf_le_sup (a := C) (b := D)) subset_span)
          (span_le_restrictScalars _ ğ•œ _)
  Â· exact inf_fg' hC hD

-- ------------------------

lemma CoFG.dual_sup_dual_inf_dual {C D : PointedCone ğ•œ M}
    (hC : C.CoFG p.flip) (hD : D.CoFG p.flip) : dual p (C âŠ“ D) = (dual p C) âŠ” (dual p D) := by
  obtain âŸ¨C', hCfg', rflâŸ© := CoFG.exists_fg_dual hC
  obtain âŸ¨D', hDfg', rflâŸ© := CoFG.exists_fg_dual hD
  simp only [Set.inf_eq_inter, â† coe_inf, â† dual_union, â† dual_sup]
  sorry

lemma inf_fg_submodule_cofg {S : Submodule ğ•œ N} (hS : S.FG) {C : PointedCone ğ•œ N} (hC : C.CoFG p) :
    True := by -- (C.restrict S).CoFG p := by -- what is the restriction of `p`???
  sorry

lemma inf_fg_submodule_cofg' {S : Submodule ğ•œ N} (hS : S.FG) {C : PointedCone ğ•œ N} (hC : C.CoFG p) :
    (S âŠ“ C : PointedCone ğ•œ N).FG := by
  sorry -- I think we first need to do finite theory, and then apply here

variable [Fact p.IsFaithfulPair] in
lemma inf_fg_cofg {C D : PointedCone ğ•œ N} (hC : C.FG) (hD : D.CoFG p) : (C âŠ“ D).FG := by
  obtain âŸ¨C', hCcofg, S, hSfg, rflâŸ© := FG.exists_cofg_sup_fg_submodule p hC
  -- obtain âŸ¨C', hCfg, rflâŸ© := FG.exists_cofg_flip_dual p hC
  -- obtain âŸ¨D', hDfg, rflâŸ© := CoFG.exists_fg_dual hD
  rw [inf_comm, â† inf_assoc]
  sorry -- can be reduced to the question "is inf of FG submodule and CoFG halfspace always FG?"

lemma CoFG.exists_fg_sup_submodule {C : PointedCone ğ•œ N} (hC : C.CoFG p)
    {S : Submodule ğ•œ N} (hS : S.CoFG p) (hCS : S â‰¤ C) :
      âˆƒ D : PointedCone ğ•œ N, D.FG âˆ§ D âŠ” S = C := by
  sorry

lemma sup_cofg {C D : PointedCone ğ•œ N} (hC : C.CoFG p) (hD : D.CoFG p) : (C âŠ” D).CoFG p := by
  obtain âŸ¨C', hCfg, rflâŸ© := CoFG.exists_fg_dual hC
  obtain âŸ¨D', hDfg, rflâŸ© := CoFG.exists_fg_dual hD
  -- need dual(C âŠ“ D) = dual(C) âŠ” dual(D)
  sorry

variable (p) [Fact p.flip.IsFaithfulPair] in
lemma dual_inf_dual_sup_dual {C D : PointedCone ğ•œ M} (hC : C.FG) (hD : D.FG) :
    dual p (C âŠ“ D) = (dual p C) âŠ” (dual p D) := by
  obtain âŸ¨C', hCcofg, rflâŸ© := FG.exists_cofg_dual_flip p hC
  obtain âŸ¨D', hDcofg, rflâŸ© := FG.exists_cofg_dual_flip p hD
  simp only [Set.inf_eq_inter]
  rw [â† coe_inf]
  rw [â† dual_sup_dual_inf_dual]
  -- rw [CoFG.fg_dual_dual_flip p.flip hfg]
  -- needs C.CoFG âˆ§ D.CoFG â†’ (C âŠ” D).CoFG
  sorry

lemma CoFG.is_dual_finite_inf_span''''' {C : PointedCone ğ•œ N} (hC : C.FG)
    (S : Submodule ğ•œ N) (hFG : S.FG) (hS : C â‰¤ S) : âˆƒ s : Set M, s.Finite âˆ§ dual p s âŠ“ S = C := by
  sorry

lemma CoFG.is_dual_finite_inf_span'''' {C : PointedCone ğ•œ N} (hC : C.FG) :
    âˆƒ s : Set M, s.Finite âˆ§ dual p s âŠ“ Submodule.span (M := N) ğ•œ C = C := by
  sorry

lemma FG.dual_span_finite_sup_lineal (hC : C.FG) :
    âˆƒ s : Set N, s.Finite âˆ§ dual p C = span ğ•œ s âŠ” (dual p C).lineal := by
  sorry

lemma FG.dual_span_finset_sup_lineal (hC : C.FG) :
    âˆƒ s : Finset N, dual p C = span ğ•œ s âŠ” (dual p C).lineal := by
  sorry

lemma CoFG.dual_sup_lineal (hC : C.FG) :
    âˆƒ D : PointedCone ğ•œ N, D.FG âˆ§ dual p C = D âŠ” (dual p C).lineal := by
  sorry

lemma CoFG.is_sup_cofg_fg (hC : C.CoFG p.flip) :
    âˆƒ D : PointedCone ğ•œ M, D.FG âˆ§ D âŠ” C.lineal = C := by
  sorry

lemma CoFG.lineal_cofg (hC : C.CoFG p.flip) : C.lineal.CoFG p.flip := by
  sorry

lemma FG.is_dual_dual_of_finite (hC : C.FG) :
    âˆƒ s : Set M, s.Finite âˆ§ dual p.flip (dual p s) = C := by
  sorry

lemma FG.is_dual_dual_of_cofg (hC : C.FG) :
    âˆƒ D : PointedCone ğ•œ N, D.CoFG p âˆ§ dual p.flip D = C := by
  sorry


-- variable [AddCommGroup N] [Module ğ•œ N] {p : M â†’â‚—[ğ•œ] N â†’â‚—[ğ•œ] ğ•œ} {s : Set M}
variable (p : M â†’â‚—[ğ•œ] N â†’â‚—[ğ•œ] ğ•œ) [p.IsPerfPair]
variable [Module.Finite ğ•œ N]

lemma FG.exists_finite_dual (hC : C.FG) :
    âˆƒ s : Set N, s.Finite âˆ§ dual p.flip s = C := by
  classical -- for Finset.induction and Finset.coe_insert
  obtain âŸ¨s, rflâŸ© := hC
  induction s using Finset.induction with
  | empty =>
    rw [Finset.coe_empty, span_empty]
    obtain âŸ¨s, hsâŸ© := fg_top (R := ğ•œ) (E := N)
    exact âŸ¨s, s.finite_toSet, by rw [â† dual_span]; simp [hs, dual_top]âŸ©
  | insert w A hwA hA =>
    obtain âŸ¨s, hfin, hsâŸ© := hA
    rw [Finset.coe_insert, span_insert, â† hs, â† dual_auxGenSet hfin]
    exact âŸ¨_, auxGenSet_finite w hfin, rflâŸ©

-- variable (ğ•œ) in
lemma FG.exists_finset_dual (hC : C.FG) :
    âˆƒ s : Finset N, dual p.flip s = C := by
  obtain âŸ¨s, sfin, hsâŸ© := FG.exists_finite_dual p hC
  exact âŸ¨ sfin.toFinset, by simp [hs] âŸ©

-- variable (ğ•œ) in
/-- A finitely generated cone is the dual of a finitely generated cone. -/
lemma FG.exists_fg_dual (hC : C.FG) :
    âˆƒ D : PointedCone ğ•œ N, D.FG âˆ§ dual p.flip D = C := by
  obtain âŸ¨s, hfin, rflâŸ© := FG.exists_finite_dual p hC
  exact âŸ¨ span ğ•œ s, fg_span hfin, dual_span _ âŸ©

-- omit [Module.Finite ğ•œ N] in
-- lemma FG.dual_sum_fg_subspace (hC : C.FG) : -- TODO: add S.CoFG
--     âˆƒ D : PointedCone ğ•œ M, D.FG âˆ§ D.IsPointy âˆ§ âˆƒ S : Submodule ğ•œ M, D âŠ” S = C := by
--   sorry

variable [Module.Finite ğ•œ M]

omit [Module.Finite ğ•œ N] in
@[simp] lemma FG.dual_dual_flip {C : PointedCone ğ•œ N} (hC : C.FG) :
    dual p (dual p.flip C) = C := by
  obtain âŸ¨s, hs, rflâŸ© := FG.exists_finite_dual p.flip hC; exact dual_dual_flip_dual _

omit [Module.Finite ğ•œ M] in
@[simp] lemma FG.dual_flip_dual {C : PointedCone ğ•œ M} (hC : C.FG) :
  dual p.flip (dual p C) = C := FG.dual_dual_flip p.flip hC

variable {p} in
omit [Module.Finite ğ•œ M] in
@[simp] lemma FG.dual_inj {Câ‚ Câ‚‚ : PointedCone ğ•œ M} (hCâ‚ : Câ‚.FG) (hCâ‚‚ : Câ‚‚.FG) :
    dual p Câ‚ = dual p Câ‚‚ â†” Câ‚ = Câ‚‚ where
  mp h := by rw [â† FG.dual_flip_dual p hCâ‚, â† FG.dual_flip_dual p hCâ‚‚, h]
  mpr h := by rw [h]

/-- The dual of a finitely generated cone is finitely generated. -/
-- Note: the converse does not hold: if the dual of C is FG, C might not.
lemma dual_fg (hC : C.FG) : (dual p C).FG := by
  obtain âŸ¨D, hfg, rflâŸ© := FG.exists_fg_dual p hC
  rw [FG.dual_dual_flip] <;> exact hfg

omit [Module.Finite ğ•œ N] in
/-- The double dual of a finite set equals the cone generated by that set. -/
lemma dual_dual_flip_eq_span {s : Set N} (hS : s.Finite) :
    dual p (dual p.flip s) = span ğ•œ s := by
  simpa using FG.dual_dual_flip p (Submodule.fg_span hS)

omit [Module.Finite ğ•œ N] in
/-- The double dual of a finite set equals the cone generated by that set. -/
lemma dual_dual_flip {C : PointedCone ğ•œ N} (hC : C.FG) :
    dual p (dual p.flip C) = C := by
  simpa using FG.dual_dual_flip p hC

omit [Module.Finite ğ•œ M] in
/-- The double dual of a finite set equals the cone generated by that set. -/
lemma dual_flip_dual_eq_span {s : Set M} (hS : s.Finite) :
    dual p.flip (dual p s) = span ğ•œ s := by
  simpa using FG.dual_dual_flip p.flip (Submodule.fg_span hS)

omit [Module.Finite ğ•œ M] in
/-- The double dual of a finite set equals the cone generated by that set. -/
lemma dual_flip_dual {C : PointedCone ğ•œ M} (hC : C.FG) :
    dual p.flip (dual p C) = C := by
  simpa using FG.dual_flip_dual p hC

variable {C C' : PointedCone ğ•œ M}

-- TODO: can we make Dual.eval a default (in the sense of Inhabited) for pairings?

-- instance : Inhabited (M â†’â‚—[ğ•œ] Dual ğ•œ (Dual ğ•œ M)) := âŸ¨ Dual.eval _ _ âŸ©
-- instance : (Dual.eval ğ•œ M).IsPerfPair := sorry

lemma inf_fg'' (hC : C.FG) (hC' : C'.FG) : (C âŠ“ C').FG := by
  obtain âŸ¨D, hfg, rflâŸ© := FG.exists_fg_dual (Dual.eval ğ•œ M) hC
  obtain âŸ¨D', hfg', rflâŸ© := FG.exists_fg_dual (Dual.eval ğ•œ M) hC'
  rw [â†dual_sup_dual_inf_dual]
  exact dual_fg .id (sup_fg hfg hfg')

/- The following lemmas are proven because they have equivalents for general cones that do
  not hold without the FG assumption -/

@[simp] lemma dual_flip_dual_inter {C C' : PointedCone ğ•œ M} (hC : C.FG) (hC' : C'.FG) :
    dual p.flip (dual p (C âˆ© C')) = C âŠ“ C' := by
  rw [â† dual_flip_dual (p := p) <| inf_fg hC hC']; simp

@[simp] lemma dual_dual_flip_inter {C C' : PointedCone ğ•œ N} (hC : C.FG) (hC' : C'.FG) :
    dual p (dual p.flip (C âˆ© C')) = C âŠ“ C' := by
  rw [â† dual_dual_flip (p := p) <| inf_fg hC hC']; simp

lemma dual_inter (hC : C.FG) (hC' : C'.FG) : dual p (C âˆ© C') = dual p C âŠ” dual p C' := by sorry
  -- rw [â† FG.dual_inj (p := p.flip), dual_sup, dual_flip_dual_inter _ hC hC',
  --   â† dual_span, span_union', dual_sup_dual_inf_dual, FG.dual_flip_dual _ hC,
  --   FG.dual_flip_dual _ hC']
  -- Â· exact dual_fg p (inf_fg hC hC')
  -- Â· exact sup_fg (dual_fg p hC) (dual_fg p hC')

-- omit p

-- /-- A linear subspace is a polyhedral cone -/
-- lemma IsPolyhedral.submodule (S : Submodule ğ•œ M) : (S : PointedCone ğ•œ M).FG
--   := PointedCone.ofSubmodule.FG_of_FG
--     <| (Submodule.fg_iff_finiteDimensional S).mpr inferInstance

end LinearOrder

end PointedCone
