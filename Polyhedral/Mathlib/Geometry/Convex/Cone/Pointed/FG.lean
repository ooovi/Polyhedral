/-
Copyright (c) 2025 Justus Springer, Martin Winter. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Justus Springer, Martin Winter
-/
import Mathlib.LinearAlgebra.Dual.Defs
import Mathlib.LinearAlgebra.PerfectPairing.Basic
import Mathlib.RingTheory.Finiteness.Basic
import Mathlib.LinearAlgebra.SesquilinearForm.Basic

import Polyhedral.Mathlib.Algebra.Module.Submodule.CoFG
import Polyhedral.Mathlib.Geometry.Convex.Cone.Pointed.Dual
import Polyhedral.Mathlib.Geometry.Convex.Cone.Pointed.CoFG

/-!
# Polyhedral cones

Given a bilinear pairing `p` between two `R`-modules `M` and `N`, we define
polyhedral cones to be pointed cones in `N` that are the dual of a finite set
in `M` (this means they are the intersection of finitely many halfspaces).

The main statement is that if both `M` and `N` are finite and the pairing is injective
in both arguments, then polyhedral cones are precisely the finitely generated cones, see
`isPolyhedral_iff_fg`. Moreover, we obtain that the dual of a polyhedral cone is again polyhedral
(`IsPolyhedral.dual`) and that the double dual of a polyhedral cone is the cone itself
(`IsPolyhedral.dual_dual_flip`, `IsPolyhedral.dual_flip_dual`).
-/

open Function Module
open Submodule hiding span dual

variable {𝕜 M N : Type*}

namespace PointedCone

alias sup_fg := Submodule.FG.sup

section LinearOrder

variable [Field 𝕜] [LinearOrder 𝕜] [IsStrictOrderedRing 𝕜] [AddCommGroup M] [AddCommGroup N]
  [Module 𝕜 M] [Module 𝕜 N] {p : M →ₗ[𝕜] N →ₗ[𝕜] 𝕜} {C : PointedCone 𝕜 M} {s : Set M} {w : N}

variable (p s w) in
/-- A set whose dual cone is `span R {w} ⊔ dual p s`, see `dual_sup_span_singleton_eq_dual` -/
private noncomputable abbrev auxGenSet : Set M :=
  {x ∈ s | 0 ≤ p x w} ∪
    .image2 (fun x y ↦ p x w • y - p y w • x) {x ∈ s | 0 ≤ p x w} {y ∈ s | p y w < 0}

variable (w) in
omit [IsStrictOrderedRing 𝕜] in
private lemma auxGenSet_finite (hs : s.Finite) :
    (auxGenSet p s w).Finite := .union (hs.sep _) <| .image2 _ (hs.sep _) (hs.sep _)

private lemma auxGenSet_subset_span :
    (auxGenSet p s w : Set M) ⊆ span 𝕜 (s : Set M) := by
  simp only [Set.union_subset_iff, Set.image2_subset_iff, Set.mem_setOf_eq, and_imp]
  refine ⟨subset_trans (fun x hx ↦ hx.1) subset_span, fun x hxS hxw y hyS hyw ↦ ?_⟩
  -- simpa [sub_eq_add_neg] using add_mem (smul_mem (span 𝕜 s) ⟨p x w, hxw⟩ (subset_span hyS))
  --   (smul_mem _ ⟨-p y w, neg_nonneg.mpr hyw.le⟩ (subset_span hxS))
  sorry -- code broke on mathlib/Lean update ?

private lemma span_singleton_le_dual_auxGenSet :
    span 𝕜 {w} ≤ dual p (auxGenSet p s w) := by
  simp only [span_singleton_le_iff_mem, mem_dual, Set.mem_union, Set.mem_setOf_eq, Set.mem_image2]
  rintro z (hz | ⟨x, ⟨hxS, hxw⟩, y, ⟨hyS, hyw⟩, rfl⟩)
  · exact hz.2
  · simp only [map_sub, map_smul, LinearMap.sub_apply, LinearMap.smul_apply, smul_eq_mul,
      sub_nonneg]
    rw [mul_comm]

/-- The crucial lemma in the proof that a finitely generated cone is polyhedral:
The sum of a polyhedral cone and the cone generated by a single ray is again polyhedral. -/
private lemma dual_auxGenSet (hs : s.Finite) :
    dual p (auxGenSet p s w) = span 𝕜 {w} ⊔ dual p s := by
  classical
  apply ge_antisymm
  · rw [← dual_span]
    exact sup_le span_singleton_le_dual_auxGenSet <| dual_le_dual auxGenSet_subset_span
  obtain hSw | hSw := {y ∈ s | p y w < 0}.eq_empty_or_nonempty
  · simp only [Set.sep_eq_empty_iff_mem_false, not_lt] at hSw
    exact le_sup_of_le_right <| dual_le_dual fun x hx => .inl ⟨hx, hSw _ hx⟩
  rw [dual_union]
  intro v ⟨hv1, hv2⟩
  rw [Submodule.mem_sup]
  replace hv2 {x y : M} (hx : x ∈ s ∧ 0 ≤ p x w) (hy : y ∈ s ∧ p y w < 0) :
      p y w * p x v ≤ p y v * p x w := by
    simp only [SetLike.mem_coe, mem_dual, Set.mem_image2, Set.mem_setOf_eq,
      forall_exists_index, and_imp] at hv2
    specialize hv2 x hx.1 hx.2 y hy.1 hy.2 rfl
    simp only [map_sub, map_smul, LinearMap.sub_apply, LinearMap.smul_apply, smul_eq_mul,
      sub_nonneg] at hv2
    nth_rw 2 [mul_comm] at hv2
    exact hv2
  obtain hSv | ⟨y, hy⟩ := {y ∈ s | p y w < 0 ∧ p y v < 0}.eq_empty_or_nonempty
  · simp +contextual only [Set.sep_and, Set.eq_empty_iff_forall_notMem, Set.mem_inter_iff,
      Set.mem_setOf_eq, not_and, true_and, not_lt, and_imp] at hSv
    refine ⟨0, zero_mem _, v, fun x hx => ?_, zero_add _⟩
    by_cases hxw : 0 ≤ p x w
    · exact hv1 ⟨hx, hxw⟩
    · exact hSv x hx (lt_of_not_ge hxw)
  lift s to Finset M using hs
  let u : 𝕜 := ({y ∈ s | p y w < 0}.image (fun y => p y v * (p y w)⁻¹)).max' <| by
    simpa [Finset.Nonempty, Set.Nonempty] using hSw.image _
  have hu : 0 ≤ u := by
    refine le_trans (mul_nonneg_of_nonpos_of_nonpos hy.2.2.le (inv_nonpos.mpr hy.2.1.le))
      (Finset.le_max' _ (p y v * (p y w)⁻¹) ?_)
    simp only [Finset.mem_image, Finset.mem_filter]
    exact ⟨y, ⟨hy.1, hy.2.1⟩, rfl⟩
  refine ⟨u • w, ?_, v - u • w, fun z hzS ↦ ?_, add_sub_cancel _ _⟩
  · rw [← Nonneg.mk_smul _ hu]
    exact Submodule.smul_mem _ _ (Submodule.subset_span rfl)
  simp only [map_sub, map_smul, smul_eq_mul, sub_nonneg]
  obtain hzw | hzw := lt_or_ge (p z w) 0
  · rw [← _root_.mul_le_mul_right_of_neg (inv_neg''.mpr hzw), mul_inv_cancel_right₀ hzw.ne]
    exact Finset.le_max' _ (p z v * (p z w)⁻¹) <|
      Finset.mem_image.mpr ⟨z, Finset.mem_filter.mpr ⟨hzS, hzw⟩, rfl⟩
  obtain ⟨y, hy, t_eq : _ = u⟩ := Finset.mem_image.mp <|
    ({y ∈ s | p y w < 0}.image (fun y => p y v * (p y w)⁻¹)).max'_mem <| by
      simpa [Finset.Nonempty, Set.Nonempty] using hSw.image _
  rw [Finset.mem_filter] at hy
  rw [← t_eq, ← _root_.mul_le_mul_left_of_neg hy.2, ← mul_assoc]
  nth_rw 4 [mul_comm]
  rw [mul_inv_cancel_left₀ hy.2.ne]
  exact hv2 ⟨hzS, hzw⟩ hy

variable {p : M →ₗ[𝕜] N →ₗ[𝕜] 𝕜}

-- The following theorems *should* not assume the finiteness of the ambient space!

variable (p) -- Q: should we make `p` implicit in some of the below?

/-- The union of an FG cone and a coFG cone is coFG. -/
lemma sup_fg_cofg {C D : PointedCone 𝕜 M} (hC : C.FG) (hD : D.CoFG) : (C ⊔ D).CoFG := by classical
  obtain ⟨s, rfl⟩ := hC
  induction s using Finset.induction with
  | empty => simp [hD]
  | insert w s hws hs =>
    obtain ⟨t, ht⟩ := hs
    use (auxGenSet .id t.toSet w).toFinset
    simp [span_insert, sup_assoc, ← ht]
    exact dual_auxGenSet t.finite_toSet

/-- An FG cone can be written as the intersection of a CoFG cone and an FG submodule. -/
lemma FG.exists_cofg_inf_submodule {C : PointedCone 𝕜 M} (hC : C.FG)
    {S : Submodule 𝕜 M} (hS : S.FG) (hCS : C ≤ S) :
      ∃ D : PointedCone 𝕜 M, D.CoFG ∧ D ⊓ S = C := by
  wlog hC' : C = ⊥ with h
  · specialize h fg_bot hS bot_le rfl
    obtain ⟨D, hcofg, hD⟩ := h
    exact ⟨_, sup_fg_cofg hC hcofg, by simp [← sup_inf_assoc_of_le_submodule D hCS, hD]⟩
  · obtain ⟨D, hcofg, hD⟩ := hS.exists_cofg_inf_bot
    exact ⟨D, coe_cofg.mpr hcofg, by simp [← restrictScalars_inf, inf_comm, hD, hC']⟩

/-- An FG cone can be written as the intersection of its linear span with a CoFG cone. -/
lemma FG.exists_cofg_sup_span {C : PointedCone 𝕜 M} (hC : C.FG) :
      ∃ D : PointedCone 𝕜 M, D.CoFG ∧ D ⊓ Submodule.span 𝕜 (M := M) C = C :=
  exists_cofg_inf_submodule hC (Submodule.span_scalars_FG hC) Submodule.subset_span

/-- An FG cone can be written as the intersection of a CoFG cone and an FG submodule. -/
lemma FG.exists_cofg_sup_fg_submodule {C : PointedCone 𝕜 M} (hC : C.FG) :
      ∃ D : PointedCone 𝕜 M, D.CoFG ∧ ∃ S : Subspace 𝕜 M, S.FG ∧ D ⊓ S = C := by
  obtain ⟨D, hcofg, hD⟩ := exists_cofg_sup_span hC
  exact ⟨D, hcofg, Submodule.span 𝕜 C, submodule_span_fg hC, hD⟩

-- We *should* be able to prove the following in this section:

lemma inf_fg_cofg {C D : PointedCone 𝕜 M} (hC : C.FG) (hD : D.CoFG) : (C ⊓ D).FG := by
  sorry

section Surjective

variable [Fact (Surjective p.flip)]

/-- An FG cone is the dual of a CoFG cone. -/
lemma FG.exists_cofg_dual {C : PointedCone 𝕜 M} (hC : C.FG) :
    ∃ D : PointedCone 𝕜 N, D.CoFG ∧ dual p.flip D = C := by
  obtain ⟨D, hD, S, hS, rfl⟩ := exists_cofg_sup_fg_submodule hC
  obtain ⟨C', hfg, rfl⟩ := CoFG.exists_fg_dual p hD
  use C' ⊔ dual p S
  constructor
  · exact sup_fg_cofg hfg <| cofg_of_fg p (ofSubmodule_fg_of_fg hS)
  · simp [dual_sup_dual_inf_dual, dual_dual_eq_of_fg hS] -- TODO: prove `dual_dual_eq_of_fg`

/-- The double dual of an FG cone is itself. -/
@[simp]
lemma FG.fg_dual_flip_dual {C : PointedCone 𝕜 M} (hC : C.FG) : dual p.flip (dual p C) = C := by
  obtain ⟨D, hcofg, rfl⟩ := exists_cofg_dual p hC
  exact dual_flip_dual_dual_flip (p := p) D

end Surjective

section Surjective'

variable [Fact (Surjective p)]

/-- The double dual of an FG cone is itself. -/
@[simp]
lemma FG.fg_dual_dual_flip {C : PointedCone 𝕜 N} (hC : C.FG) : dual p (dual p.flip C) = C := by
  obtain ⟨D, hcofg, rfl⟩ := exists_cofg_dual p.flip hC
  exact dual_dual_flip_dual (p := p) D

end Surjective'

section IsPerfPair

variable [p.IsPerfPair]

-- TODO: For everything in this section:
--   Is there a proof that only requires surjectivity of `p.flip` instead of `p.IsPerfPair`?

/-- The dual of a CoFG cone is FG. -/
lemma CoFG.dual_fg {C : PointedCone 𝕜 M} (hC : C.CoFG) : (dual p C).FG := by
  obtain ⟨D, hfg, rfl⟩ := exists_fg_dual p hC
  rw [FG.fg_dual_dual_flip p hfg]
  exact hfg

lemma CoFG.dual_fg' {C : PointedCone 𝕜 N} (hC : C.CoFG) : (dual p.flip C).FG := by
  obtain ⟨D, hfg, rfl⟩ := exists_fg_dual p.flip hC
  rw [LinearMap.flip_flip]
  rw [FG.fg_dual_flip_dual p hfg]
  exact hfg

variable [Module.Finite 𝕜 M] in
lemma inf_fg_cofg' {C D : PointedCone 𝕜 M} (hC : C.FG) (hD : D.CoFG) : (C ⊓ D).FG := by
  obtain ⟨C', hCfg, rfl⟩ := FG.exists_cofg_dual (Dual.eval 𝕜 M) hC
  obtain ⟨D', hDfg, rfl⟩ := CoFG.exists_fg_dual (Dual.eval 𝕜 M) hD
  rw [← dual_union, ← dual_sup]
  apply CoFG.dual_fg -- here we need finite dim
  -- TODO -- here we need `(C ⊔ D).CoFG` if `C` and `D` are CoFG.
  sorry

lemma dual_inf_dual_sup_dual {C D : PointedCone 𝕜 M} (hC : C.FG) (hD : D.FG) :
    dual p (C ⊓ D) = (dual p C) ⊔ (dual p D) := by
  obtain ⟨C', hCfg, rfl⟩ := hC
  obtain ⟨D', hDfg, rfl⟩ := hD
  -- rw [dual_sup]
  sorry

lemma sup_cofg {C D : PointedCone 𝕜 M} (hC : C.CoFG) (hD : D.CoFG) : (C ⊔ D).CoFG := by
  obtain ⟨C', hCfg, rfl⟩ := CoFG.exists_fg_dual (Dual.eval 𝕜 M) hC
  obtain ⟨D', hDfg, rfl⟩ := CoFG.exists_fg_dual (Dual.eval 𝕜 M) hD
  sorry

lemma CoFG.exists_fg_sup_submodule {C : PointedCone 𝕜 M} (hC : C.CoFG)
    {S : Submodule 𝕜 M} (hS : S.CoFG) (hCS : S ≤ C) :
      ∃ D : PointedCone 𝕜 M, D.FG ∧ D ⊔ S = C := by
  sorry

lemma inf_fg {C D : PointedCone 𝕜 M} (hC : C.FG) (hD : D.FG) : (C ⊓ D).FG := by
  obtain ⟨C', hCcofg, rfl⟩ := FG.exists_cofg_dual (Dual.eval 𝕜 M) hC
  obtain ⟨D', hDcofg, rfl⟩ := FG.exists_cofg_dual (Dual.eval 𝕜 M) hD
  rw [← dual_sup_dual_inf_dual]
  -- exact CoFG.dual_fg (sup_cofg)
  sorry

lemma inf_fg' {C D : PointedCone 𝕜 M} (hC : C.FG) (hD : D.FG) : (C ⊓ D).FG := by
  let CD : Submodule 𝕜 M := Submodule.span 𝕜 (C ⊔ D)
  have hCD : CD.FG := by sorry
  have hCD_C : C ≤ CD := by sorry
  have hCD_D : D ≤ CD := by sorry
  obtain ⟨C', hCcofg, hC'⟩ := FG.exists_cofg_inf_submodule hC hCD hCD_C
  obtain ⟨D', hDcofg, hD'⟩ := FG.exists_cofg_inf_submodule hD hCD hCD_D
  rw [← hC', ← hD']
  rw [inf_assoc]
  nth_rw 2 [inf_comm]
  rw [inf_assoc, ← inf_assoc]
  simp
  -- obtain ⟨C', hCcofg, rfl⟩ := FG.exists_dual_cofg (Dual.eval 𝕜 M) hC
  -- obtain ⟨D', hDcofg, rfl⟩ := FG.exists_dual_cofg (Dual.eval 𝕜 M) hD
  -- rw [← dual_sup_dual_inf_dual]
  -- exact CoFG.dual_fg (sup_cofg)
  sorry

end IsPerfPair

lemma CoFG.is_dual_finite_inf_span''''' {C : PointedCone 𝕜 N} (hC : C.FG)
    (S : Submodule 𝕜 N) (hFG : S.FG) (hS : C ≤ S) : ∃ s : Set M, s.Finite ∧ dual p s ⊓ S = C := by
  sorry

lemma CoFG.is_dual_finite_inf_span'''' {C : PointedCone 𝕜 N} (hC : C.FG) :
    ∃ s : Set M, s.Finite ∧ dual p s ⊓ Submodule.span (M := N) 𝕜 C = C := by
  sorry

lemma FG.dual_span_finite_sup_lineal (hC : C.FG) :
    ∃ s : Set N, s.Finite ∧ dual p C = span 𝕜 s ⊔ (dual p C).lineal := by
  sorry

lemma FG.dual_span_finset_sup_lineal (hC : C.FG) :
    ∃ s : Finset N, dual p C = span 𝕜 s ⊔ (dual p C).lineal := by
  sorry

lemma CoFG.dual_sup_lineal (hC : C.FG) :
    ∃ D : PointedCone 𝕜 N, D.FG ∧ dual p C = D ⊔ (dual p C).lineal := by
  sorry

lemma CoFG.is_sup_cofg_fg (hC : C.CoFG) :
    ∃ D : PointedCone 𝕜 M, D.FG ∧ D ⊔ C.lineal = C := by
  sorry

lemma CoFG.lineal_cofg (hC : C.CoFG) : C.lineal.CoFG := by
  sorry

lemma FG.is_dual_dual_of_finite (hC : C.FG) :
    ∃ s : Set M, s.Finite ∧ dual p.flip (dual p s) = C := by
  sorry

lemma FG.is_dual_dual_of_cofg (hC : C.FG) :
    ∃ D : PointedCone 𝕜 N, D.CoFG ∧ dual p.flip D = C := by
  sorry


-- variable [AddCommGroup N] [Module 𝕜 N] {p : M →ₗ[𝕜] N →ₗ[𝕜] 𝕜} {s : Set M}
variable (p : M →ₗ[𝕜] N →ₗ[𝕜] 𝕜) [p.IsPerfPair]
variable [Module.Finite 𝕜 N]

lemma FG.exists_finite_dual (hC : C.FG) :
    ∃ s : Set N, s.Finite ∧ dual p.flip s = C := by
  classical -- for Finset.induction and Finset.coe_insert
  obtain ⟨s, rfl⟩ := hC
  induction s using Finset.induction with
  | empty =>
    rw [Finset.coe_empty, span_empty]
    obtain ⟨s, hs⟩ := fg_top (R := 𝕜) (E := N)
    exact ⟨s, s.finite_toSet, by rw [← dual_span]; simp [hs, dual_top]⟩
  | insert w A hwA hA =>
    obtain ⟨s, hfin, hs⟩ := hA
    rw [Finset.coe_insert, span_insert, ← hs, ← dual_auxGenSet hfin]
    exact ⟨_, auxGenSet_finite w hfin, rfl⟩

-- variable (𝕜) in
lemma FG.exists_finset_dual (hC : C.FG) :
    ∃ s : Finset N, dual p.flip s = C := by
  obtain ⟨s, sfin, hs⟩ := FG.exists_finite_dual p hC
  exact ⟨ sfin.toFinset, by simp [hs] ⟩

-- variable (𝕜) in
/-- A finitely generated cone is the dual of a finitely generated cone. -/
lemma FG.exists_fg_dual (hC : C.FG) :
    ∃ D : PointedCone 𝕜 N, D.FG ∧ dual p.flip D = C := by
  obtain ⟨s, hfin, rfl⟩ := FG.exists_finite_dual p hC
  exact ⟨ span 𝕜 s, fg_span hfin, dual_span _ ⟩

-- omit [Module.Finite 𝕜 N] in
-- lemma FG.dual_sum_fg_subspace (hC : C.FG) : -- TODO: add S.CoFG
--     ∃ D : PointedCone 𝕜 M, D.FG ∧ D.IsPointy ∧ ∃ S : Submodule 𝕜 M, D ⊔ S = C := by
--   sorry

variable [Module.Finite 𝕜 M]

omit [Module.Finite 𝕜 N] in
@[simp] lemma FG.dual_dual_flip {C : PointedCone 𝕜 N} (hC : C.FG) :
    dual p (dual p.flip C) = C := by
  obtain ⟨s, hs, rfl⟩ := FG.exists_finite_dual p.flip hC; exact dual_dual_flip_dual _

omit [Module.Finite 𝕜 M] in
@[simp] lemma FG.dual_flip_dual {C : PointedCone 𝕜 M} (hC : C.FG) :
  dual p.flip (dual p C) = C := FG.dual_dual_flip p.flip hC

variable {p} in
omit [Module.Finite 𝕜 M] in
@[simp] lemma FG.dual_inj {C₁ C₂ : PointedCone 𝕜 M} (hC₁ : C₁.FG) (hC₂ : C₂.FG) :
    dual p C₁ = dual p C₂ ↔ C₁ = C₂ where
  mp h := by rw [← FG.dual_flip_dual p hC₁, ← FG.dual_flip_dual p hC₂, h]
  mpr h := by rw [h]

/-- The dual of a finitely generated cone is finitely generated. -/
-- Note: the converse does not hold: if the dual of C is FG, C might not.
lemma dual_fg (hC : C.FG) : (dual p C).FG := by
  obtain ⟨D, hfg, rfl⟩ := FG.exists_fg_dual p hC
  rw [FG.dual_dual_flip] <;> exact hfg

omit [Module.Finite 𝕜 N] in
/-- The double dual of a finite set equals the cone generated by that set. -/
lemma dual_dual_flip_eq_span {s : Set N} (hS : s.Finite) :
    dual p (dual p.flip s) = span 𝕜 s := by
  simpa using FG.dual_dual_flip p (Submodule.fg_span hS)

omit [Module.Finite 𝕜 N] in
/-- The double dual of a finite set equals the cone generated by that set. -/
lemma dual_dual_flip {C : PointedCone 𝕜 N} (hC : C.FG) :
    dual p (dual p.flip C) = C := by
  simpa using FG.dual_dual_flip p hC

omit [Module.Finite 𝕜 M] in
/-- The double dual of a finite set equals the cone generated by that set. -/
lemma dual_flip_dual_eq_span {s : Set M} (hS : s.Finite) :
    dual p.flip (dual p s) = span 𝕜 s := by
  simpa using FG.dual_dual_flip p.flip (Submodule.fg_span hS)

omit [Module.Finite 𝕜 M] in
/-- The double dual of a finite set equals the cone generated by that set. -/
lemma dual_flip_dual {C : PointedCone 𝕜 M} (hC : C.FG) :
    dual p.flip (dual p C) = C := by
  simpa using FG.dual_flip_dual p hC

variable {C C' : PointedCone 𝕜 M}

-- TODO: can we make Dual.eval a default (in the sense of Inhabited) for pairings?

-- instance : Inhabited (M →ₗ[𝕜] Dual 𝕜 (Dual 𝕜 M)) := ⟨ Dual.eval _ _ ⟩
-- instance : (Dual.eval 𝕜 M).IsPerfPair := sorry

lemma inf_fg'' (hC : C.FG) (hC' : C'.FG) : (C ⊓ C').FG := by
  obtain ⟨D, hfg, rfl⟩ := FG.exists_fg_dual (Dual.eval 𝕜 M) hC
  obtain ⟨D', hfg', rfl⟩ := FG.exists_fg_dual (Dual.eval 𝕜 M) hC'
  rw [←dual_sup_dual_inf_dual]
  exact dual_fg .id (sup_fg hfg hfg')

/- The following lemmas are proven because they have equivalents for general cones that do
  not hold without the FG assumption -/

@[simp] lemma dual_flip_dual_inter {C C' : PointedCone 𝕜 M} (hC : C.FG) (hC' : C'.FG) :
    dual p.flip (dual p (C ∩ C')) = C ⊓ C' := by
  rw [← dual_flip_dual (p := p) <| inf_fg hC hC']; simp

@[simp] lemma dual_dual_flip_inter {C C' : PointedCone 𝕜 N} (hC : C.FG) (hC' : C'.FG) :
    dual p (dual p.flip (C ∩ C')) = C ⊓ C' := by
  rw [← dual_dual_flip (p := p) <| inf_fg hC hC']; simp

lemma dual_inter (hC : C.FG) (hC' : C'.FG) : dual p (C ∩ C') = dual p C ⊔ dual p C' := by sorry
  -- rw [← FG.dual_inj (p := p.flip), dual_sup, dual_flip_dual_inter _ hC hC',
  --   ← dual_span, span_union', dual_sup_dual_inf_dual, FG.dual_flip_dual _ hC,
  --   FG.dual_flip_dual _ hC']
  -- · exact dual_fg p (inf_fg hC hC')
  -- · exact sup_fg (dual_fg p hC) (dual_fg p hC')

-- omit p

-- /-- A linear subspace is a polyhedral cone -/
-- lemma IsPolyhedral.submodule (S : Submodule 𝕜 M) : (S : PointedCone 𝕜 M).FG
--   := PointedCone.ofSubmodule.FG_of_FG
--     <| (Submodule.fg_iff_finiteDimensional S).mpr inferInstance

end LinearOrder

end PointedCone
