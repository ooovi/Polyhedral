/-
Copyright (c) 2025 Justus Springer, Martin Winter. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Justus Springer, Martin Winter
-/
import Mathlib.LinearAlgebra.Dual.Defs
import Mathlib.LinearAlgebra.PerfectPairing.Basic
import Mathlib.RingTheory.Finiteness.Basic
import Mathlib.LinearAlgebra.SesquilinearForm.Basic

import Polyhedral.Mathlib.Algebra.Module.Submodule.DualClosed
import Polyhedral.Mathlib.Geometry.Convex.Cone.Pointed.FGDual

/-!
# Polyhedral cones

Given a bilinear pairing `p` between two `R`-modules `M` and `N`, we define
polyhedral cones to be pointed cones in `N` that are the dual of a finite set
in `M` (this means they are the intersection of finitely many halfspaces).

The main statement is that if both `M` and `N` are finite and the pairing is injective
in both arguments, then polyhedral cones are precisely the finitely generated cones, see
`isPolyhedral_iff_fg`. Moreover, we obtain that the dual of a polyhedral cone is again polyhedral
(`IsPolyhedral.dual`) and that the double dual of a polyhedral cone is the cone itself
(`IsPolyhedral.dual_dual_flip`, `IsPolyhedral.dual_flip_dual`).
-/

open Function Module LinearMap
open Submodule hiding span dual
open Set

variable {ğ•œ M N : Type*}

namespace PointedCone

alias sup_fg := Submodule.FG.sup

section LinearOrder

variable [Field ğ•œ] [LinearOrder ğ•œ] [IsOrderedRing ğ•œ] [AddCommGroup M] [AddCommGroup N]
  [Module ğ•œ M] [Module ğ•œ N] {p : M â†’â‚—[ğ•œ] N â†’â‚—[ğ•œ] ğ•œ} {C : PointedCone ğ•œ M} {s : Set M} {w : N}

variable (p s w) in
/-- A set whose dual cone is `span R {w} âŠ” dual p s`, see `dual_sup_span_singleton_eq_dual` -/
private noncomputable abbrev auxGenSet : Set M :=
  {x âˆˆ s | 0 â‰¤ p x w} âˆª
    .image2 (fun x y â†¦ p x w â€¢ y - p y w â€¢ x) {x âˆˆ s | 0 â‰¤ p x w} {y âˆˆ s | p y w < 0}

variable (w) in
omit [IsOrderedRing ğ•œ] in
private lemma auxGenSet_finite (hs : s.Finite) :
    (auxGenSet p s w).Finite := .union (hs.sep _) <| .image2 _ (hs.sep _) (hs.sep _)

private lemma auxGenSet_subset_span :
    (auxGenSet p s w : Set M) âŠ† span ğ•œ (s : Set M) := by
  simp only [Set.union_subset_iff, Set.image2_subset_iff, Set.mem_setOf_eq, and_imp]
  refine âŸ¨subset_trans (fun x hx â†¦ hx.1) subset_span, fun x hxS hxw y hyS hyw â†¦ ?_âŸ©
  simpa [sub_eq_add_neg, â† neg_smul] using add_mem (smul_mem (span ğ•œ s) hxw (subset_span hyS))
    (smul_mem _ (neg_nonneg.mpr hyw.le) (subset_span hxS))

private lemma span_singleton_le_dual_auxGenSet :
    span ğ•œ {w} â‰¤ dual p (auxGenSet p s w) := by
  simp only [span_singleton_le_iff_mem, mem_dual, Set.mem_union, Set.mem_setOf_eq, Set.mem_image2]
  rintro z (hz | âŸ¨x, âŸ¨hxS, hxwâŸ©, y, âŸ¨hyS, hywâŸ©, rflâŸ©)
  Â· exact hz.2
  Â· simp only [map_sub, map_smul, LinearMap.sub_apply, LinearMap.smul_apply, smul_eq_mul,
      sub_nonneg]
    rw [mul_comm]

/-- The crucial lemma in the proof that a finitely generated cone is polyhedral:
The sum of a polyhedral cone and the cone generated by a single ray is again polyhedral. -/
private lemma dual_auxGenSet (hs : s.Finite) :
    dual p (auxGenSet p s w) = span ğ•œ {w} âŠ” dual p s := by
  classical
  apply ge_antisymm
  Â· rw [â† dual_span]
    exact sup_le span_singleton_le_dual_auxGenSet <| dual_le_dual auxGenSet_subset_span
  obtain hSw | hSw := {y âˆˆ s | p y w < 0}.eq_empty_or_nonempty
  Â· simp only [Set.sep_eq_empty_iff_mem_false, not_lt] at hSw
    exact le_sup_of_le_right <| dual_le_dual fun x hx => .inl âŸ¨hx, hSw _ hxâŸ©
  rw [dual_union]
  intro v âŸ¨hv1, hv2âŸ©
  rw [Submodule.mem_sup]
  replace hv2 {x y : M} (hx : x âˆˆ s âˆ§ 0 â‰¤ p x w) (hy : y âˆˆ s âˆ§ p y w < 0) :
      p y w * p x v â‰¤ p y v * p x w := by
    simp only [SetLike.mem_coe, mem_dual, Set.mem_image2, Set.mem_setOf_eq,
      forall_exists_index, and_imp] at hv2
    specialize hv2 x hx.1 hx.2 y hy.1 hy.2 rfl
    simp only [map_sub, map_smul, LinearMap.sub_apply, LinearMap.smul_apply, smul_eq_mul,
      sub_nonneg] at hv2
    nth_rw 2 [mul_comm] at hv2
    exact hv2
  obtain hSv | âŸ¨y, hyâŸ© := {y âˆˆ s | p y w < 0 âˆ§ p y v < 0}.eq_empty_or_nonempty
  Â· simp +contextual only [Set.sep_and, Set.eq_empty_iff_forall_notMem, Set.mem_inter_iff,
      Set.mem_setOf_eq, not_and, true_and, not_lt, and_imp] at hSv
    refine âŸ¨0, zero_mem _, v, fun x hx => ?_, zero_add _âŸ©
    by_cases hxw : 0 â‰¤ p x w
    Â· exact hv1 âŸ¨hx, hxwâŸ©
    Â· exact hSv x hx (lt_of_not_ge hxw)
  lift s to Finset M using hs
  let u : ğ•œ := ({y âˆˆ s | p y w < 0}.image (fun y => p y v * (p y w)â»Â¹)).max' <| by
    simpa [Finset.Nonempty, Set.Nonempty] using hSw
  have hu : 0 â‰¤ u := by
    refine le_trans (mul_nonneg_of_nonpos_of_nonpos hy.2.2.le (inv_nonpos.mpr hy.2.1.le))
      (Finset.le_max' _ (p y v * (p y w)â»Â¹) ?_)
    simp only [Finset.mem_image, Finset.mem_filter]
    exact âŸ¨y, âŸ¨hy.1, hy.2.1âŸ©, rflâŸ©
  refine âŸ¨u â€¢ w, ?_, v - u â€¢ w, fun z hzS â†¦ ?_, add_sub_cancel _ _âŸ©
  Â· rw [â† Nonneg.mk_smul _ hu]
    exact Submodule.smul_mem _ _ (Submodule.subset_span rfl)
  simp only [map_sub, map_smul, smul_eq_mul, sub_nonneg]
  obtain hzw | hzw := lt_or_ge (p z w) 0
  Â· rw [â† _root_.mul_le_mul_right_of_neg (inv_neg''.mpr hzw), mul_inv_cancel_rightâ‚€ hzw.ne]
    exact Finset.le_max' _ (p z v * (p z w)â»Â¹) <|
      Finset.mem_image.mpr âŸ¨z, Finset.mem_filter.mpr âŸ¨hzS, hzwâŸ©, rflâŸ©
  obtain âŸ¨y, hy, t_eq : _ = uâŸ© := Finset.mem_image.mp <|
    ({y âˆˆ s | p y w < 0}.image (fun y => p y v * (p y w)â»Â¹)).max'_mem <| by
      simpa [Finset.Nonempty, Set.Nonempty] using hSw
  rw [Finset.mem_filter] at hy
  rw [â† t_eq, â† _root_.mul_le_mul_left_of_neg hy.2, â† mul_assoc]
  nth_rw 4 [mul_comm]
  rw [mul_inv_cancel_leftâ‚€ hy.2.ne]
  exact hv2 âŸ¨hzS, hzwâŸ© hy

-- <<<<<<<<<<<<<<<<<<<<<<<<<<<<<

-- lemma xxx {g : M â†’â‚—[ğ•œ] ğ•œ} (hg : âˆ€ x âˆˆ C, 0 â‰¤ g x) : âˆ€ x âˆˆ C.lineal, g x = 0 := sorry

def max {C : PointedCone ğ•œ M} (f : M â†’â‚—[ğ•œ] ğ•œ) {g : M â†’â‚—[ğ•œ] ğ•œ}
    (hg : âˆ€ x âˆˆ C, 0 â‰¤ g x âˆ§ (g x = 0 â†’ x = 0)) : PointedCone ğ•œ M where
  carrier := {x âˆˆ C | x â‰  0 â†’ âˆ€ y âˆˆ C, y â‰  0 â†’ f y / g y â‰¤ f x / g x}
  add_mem' := by
    simp only [ne_eq, mem_setOf_eq, map_add, and_imp]
    intro x y hxC hx hyC hy
    constructor
    Â· exact C.add_mem hxC hyC
    intro hxy z hzC hz0
    --specialize hx
    sorry
  zero_mem' := by simp
  smul_mem' := by
    simp only [ne_eq, mem_setOf_eq, smul_eq_zero, not_or, map_smul_of_tower, and_imp,
      Subtype.forall, Nonneg.mk_smul, Nonneg.mk_eq_zero, smul_eq_mul]
    intro _ ha _ hxC h
    constructor
    Â· exact C.smul_mem ha hxC
    intro ha'
    simp only [div_eq_mul_inv, mul_inv_rev] at âŠ¢ h
    rw [mul_comm, mul_assoc]
    nth_rw 2 [â† mul_assoc]
    rw [inv_mul_cancelâ‚€ ha', one_mul, mul_comm]
    exact h

def max_isFaceOf {C : PointedCone ğ•œ M} (f : M â†’â‚—[ğ•œ] ğ•œ) {g : M â†’â‚—[ğ•œ] ğ•œ} (hg : âˆ€ x âˆˆ C, 0 â‰¤ g x) :
    (C.max f hg).IsFaceOf C := sorry

def max_nonempty {C : PointedCone ğ•œ M} (hfg : C.FG) (f : M â†’â‚—[ğ•œ] ğ•œ) {g : M â†’â‚—[ğ•œ] ğ•œ}
    (hg : âˆ€ x âˆˆ C, 0 â‰¤ g x) : Nonempty (C.max f hg) := by
  obtain âŸ¨s, rflâŸ© := hfg
  by_cases hs : s.Nonempty
  Â· let s' := s.image fun x => f x / g x
    have hs' : s'.Nonempty := by simp [s', hs]
    have hcx := Finset.max'_mem s' hs'
    obtain âŸ¨x, hxs, hfxâŸ© := Finset.mem_image.mp hcx
    use x
    simp only [max, ne_eq, mem_mk, AddSubmonoid.mem_mk, AddSubsemigroup.mem_mk, mem_setOf_eq]
    constructor
    Â· exact subset_span hxs
    intro hx0 y hy hy0
    have := Finset.le_max' s' (f y / g y) (by simp [s']; use y)
    sorry
  Â· simp at hs
    simp [max, hs]

lemma FG.max_of_hom_nonempty {C : PointedCone ğ•œ M} (hfg : C.FG) (f : M â†’â‚—[ğ•œ] ğ•œ) (hf : PosHom f) :
    Nonempty (C.max_of_hom hf) := by
  obtain âŸ¨s, rflâŸ© := hfg
  by_cases hs' : s.Nonempty
  Â· let s' := s.image fun x => f x
    have hs' : s'.Nonempty := Finset.image_nonempty.mpr hs'
    let cx := s'.max' hs'
    have hcx := Finset.max'_mem (s.image fun x => f x) hs'
    obtain âŸ¨x, hxs, hfxâŸ© := Finset.mem_image.mp hcx
    use x
    constructor
    Â· exact subset_span hxs
    rw [hfx]
    -- obtain âŸ¨z, hzs, hfzâŸ© := Finset.mem_image.mp hcx
    -- rw [â† hfz]; clear hfz
    -- have := Finset.le_max' s' (f z) (by sorry)
    -- simp [s'] at this
    intro y hy
    have := Finset.le_max' s' (f y)
    have : f y âˆˆ s' := by
      simp [s']
      use y
    sorry
  Â· simp at hs'
    use 0
    simp [hs']


lemma span_le_of_le {s : Set M} {C : PointedCone ğ•œ M} (hs : s âŠ† C) : span ğ•œ s â‰¤ C := by
  simpa using (Submodule.span_mono hs : span ğ•œ s â‰¤ span ğ•œ C)

lemma aux {s : Set M} {x : M} (hx : x âˆˆ span ğ•œ s) {w : N} (hw : p x w < 0) :
    âˆƒ y âˆˆ s, p y w < 0 := by
  by_contra h
  push_neg at h
  absurd hw
  push_neg
  have : s âŠ† dual p.flip {w} := fun x hx => by simp [h x hx]
  simpa using (span_mono this) hx

private lemma dual_auxGenSet'' {C : PointedCone ğ•œ M} (hC : C.FG) :
    dual p (auxGenSet p C w) = .span ğ•œ {w} âŠ” dual p C := by classical

  apply ge_antisymm
  Â· -- easy direction: RHS â‰¤ LHS
    rw [â† dual_span]
    exact sup_le span_singleton_le_dual_auxGenSet <|
      dual_le_dual auxGenSet_subset_span

  -- hard direction: LHS â‰¤ RHS
  -- We'll reuse your proof, but weâ€™ll take max over a finite generator finset S.
  obtain hSw | hSw := {y âˆˆ (C : Set M) | p y w < 0}.eq_empty_or_nonempty
  Â· -- If nothing in C has p _ w < 0, then every xâˆˆC satisfies 0â‰¤p x w, hence C âŠ† first part of auxGenSet
    simp only [Set.sep_eq_empty_iff_mem_false, not_lt] at hSw
    exact le_sup_of_le_right <|
      dual_le_dual (fun x hxC => .inl âŸ¨hxC, hSw _ hxCâŸ©)

  -- Now {yâˆˆC | p y w < 0} is nonempty.
  -- Expand auxGenSet = A âˆª B and unpack membership in the dual.
  rw [dual_union]
  intro v âŸ¨hv1, hv2âŸ©
  rw [Submodule.mem_sup]

  -- The same key inequality extracted from hv2 as in your finite proof:
  replace hv2 {x y : M}
      (hx : x âˆˆ (C : Set M) âˆ§ 0 â‰¤ p x w)
      (hy : y âˆˆ (C : Set M) âˆ§ p y w < 0) :
      p y w * p x v â‰¤ p y v * p x w := by
    simp only [SetLike.mem_coe, mem_dual, Set.mem_image2, Set.mem_setOf_eq,
      forall_exists_index, and_imp] at hv2
    specialize hv2 x hx.1 hx.2 y hy.1 hy.2 rfl
    simp only [map_sub, map_smul, LinearMap.sub_apply, LinearMap.smul_apply,
      smul_eq_mul, sub_nonneg] at hv2
    nth_rw 2 [mul_comm] at hv2
    exact hv2

  -- Next split exactly as before, but over C (not generators):
  obtain hSv | âŸ¨y, hyâŸ© :=
      {y âˆˆ (C : Set M) | p y w < 0 âˆ§ p y v < 0}.eq_empty_or_nonempty
  Â· -- If no y in C is simultaneously w-negative and v-negative, then v âˆˆ dual p C directly (same argument)
    simp +contextual only [Set.sep_and, Set.eq_empty_iff_forall_notMem, Set.mem_inter_iff,
      Set.mem_setOf_eq, not_and, true_and, not_lt, and_imp] at hSv
    refine âŸ¨0, zero_mem _, v, ?_, zero_add _âŸ©
    -- show v âˆˆ dual p C
    intro x hxC
    by_cases hxw : 0 â‰¤ p x w
    Â· exact hv1 âŸ¨hxC, hxwâŸ©
    Â· exact hSv x hxC (lt_of_not_ge hxw)

  ----------------------------------------------------------------
  -- Hardest branch: there exists yâˆˆC with p y w <0 and p y v <0.
  -- Here we use FG to extract a finite generator finset S and run the max argument on S.
  ----------------------------------------------------------------

  -- Extract generators: C = span S
  obtain âŸ¨s, hCSâŸ© := hC
  -- We will rewrite dual p C to dual p (S : Set M) using dual_span.
  have hdualC : dual p C = dual p s := by
    -- C = span S, then dual p C = dual p (span S) = dual p S
    -- adjust lemma names if needed
    simpa [hCS] using (dual_span (p := p) (s := s))

  -- A convenient lemma: any generator z âˆˆ S is in C
  have hS_sub : (s : Set M) âŠ† (C : Set M) := by
    intro z hzS
    -- z âˆˆ span S = C
    -- adjust lemma name: typically `PointedCone.subset_span` or `Submodule.subset_span`
    simpa [hCS] using (PointedCone.subset_span (R := ğ•œ) (s := (s : Set M)) hzS)

  have hysw : {y âˆˆ s | (p y) w < 0}.Nonempty := by -- TODO: improve this code
    obtain âŸ¨y, hyâŸ© := hSw
    simp at hy
    rw [â† hCS] at hy
    obtain âŸ¨y, hyâŸ© := aux hy.1 hy.2
    use y
    simpa using hy
      -- nonempty: we need at least one generator with p _ w < 0.
      -- This follows from hSw plus the fact C is generated by S:
      -- if all generators had 0 â‰¤ p _ w, then every xâˆˆC would satisfy 0 â‰¤ p x w, contradicting hSw.
      -- You may already have a lemma for this; otherwise prove it with a small conic-combination argument.

  -- Define u as max of ratios over the NEGATIVE-on-w generators.
  let u : ğ•œ := ({y âˆˆ s | p y w < 0}.image (fun y => p y v * (p y w)â»Â¹)).max' (by simp [hysw])

  -- Show u â‰¥ 0. In the finite proof this came from picking y with p y w <0 and p y v <0.
  -- We do the same, but we need a generator y0 with BOTH negatives.
  have hu : 0 â‰¤ u := by
    -- From âŸ¨y, hyâŸ© with yâˆˆC and both negatives, and vâˆˆdual(auxGenSet),
    -- one shows there exists y0âˆˆS with p y0 w <0 and p y0 v <0.
    -- Then ratio(y0) â‰¥ 0 and u, being the max, is â‰¥ ratio(y0).
    -- This is the only additional â€œgenerator extractionâ€ sub-lemma you need.
    have : âˆƒ y0 âˆˆ s, p y0 w < 0 âˆ§ p y0 v < 0 := by

      -- Sketch:
      -- 1) write y as conic combination of generators (using hCS and hy.1 : yâˆˆC)
      -- 2) use hv1 to show any generator with 0â‰¤p _ w must have 0â‰¤p _ v (since it lies in A)
      -- 3) since p y v < 0, some generator must have p _ v < 0, hence also p _ w < 0
      -- Implement using the representation lemma for `PointedCone.mem_span`.
      sorry
    rcases this with âŸ¨y0, hy0S, hy0w, hy0vâŸ©
    refine le_trans ?_ (Finset.le_max' _ (p y0 v * (p y0 w)â»Â¹) ?_)
    Â· -- ratio(y0) â‰¥ 0 since both numerator and denominator are < 0
      exact mul_nonneg_of_nonpos_of_nonpos hy0v.le (inv_nonpos.mpr hy0w.le)
    Â· -- show ratio(y0) is in the finset image
      simp only [Finset.mem_image, Finset.mem_filter]
      exact âŸ¨y0, âŸ¨hy0S, hy0wâŸ©, rflâŸ©

  -- Now decompose v = (uâ€¢w) + (v - uâ€¢w)
  refine âŸ¨u â€¢ w, ?_, v - u â€¢ w, ?_, add_sub_cancel _ _âŸ©
  Â· -- uâ€¢w âˆˆ span{w} with uâ‰¥0 (pointed span)
    rw [â† Nonneg.mk_smul _ hu]
    exact Submodule.smul_mem _ _ (Submodule.subset_span rfl)

  -- show v - uâ€¢w âˆˆ dual p C; rewrite to generators via hdualC
  -- (this is where FG really matters)
  -- Goal becomes: âˆ€ z âˆˆ S, 0 â‰¤ p z (v - uâ€¢w)
  -- after simp itâ€™s the same split-by-sign proof as your finite-set version.
  -- Use `hdualC` to replace `dual p C` by `dual p (S:Set M)`:
  have : v - u â€¢ w âˆˆ dual p s := by
    intro z hzS
    -- We need: 0 â‰¤ p z (v - uâ€¢w)
    simp only [map_sub, map_smul, smul_eq_mul, sub_nonneg]
    -- split on sign of p z w
    obtain hzw | hzw := lt_or_ge (p z w) 0
    Â· -- z has p z w < 0: u is a max over those ratios, identical to your finite proof
      rw [â† _root_.mul_le_mul_right_of_neg (inv_neg''.mpr hzw),
        mul_inv_cancel_rightâ‚€ hzw.ne]
      exact Finset.le_max' _ (p z v * (p z w)â»Â¹) <|
        Finset.mem_image.mpr âŸ¨z, Finset.mem_filter.mpr âŸ¨hzS, hzwâŸ©, rflâŸ©
    Â· -- z has 0 â‰¤ p z w: use the key inequality hv2 with y that attains the max
      obtain âŸ¨y0, hy0, HâŸ© := Finset.mem_image.mp <|
        ({y âˆˆ s | p y w < 0}.image (fun y => p y v * (p y w)â»Â¹)).max'_mem (by simp [hysw])
      -- unpack hy0 : y0 âˆˆ S âˆ§ p y0 w < 0
      have hy0S : y0 âˆˆ (s : Set M) := by
        simpa [Finset.mem_filter] using (Finset.mem_filter.mp hy0).1
      have hy0w : p y0 w < 0 := by
        simpa [Finset.mem_filter] using (Finset.mem_filter.mp hy0).2
      -- Now apply hv2 with x=z (needs zâˆˆC and 0â‰¤p z w) and y=y0 (needs y0âˆˆC and p y0 w <0)
      have hzC : z âˆˆ (C : Set M) := hS_sub hzS
      have hy0C : y0 âˆˆ (C : Set M) := hS_sub hy0S
      -- Rearrangement is exactly your last 6 lines:
      rw [â† _root_.mul_le_mul_left_of_neg hy0w, â† mul_assoc]
      nth_rw 4 [mul_comm]
      rw [mul_inv_cancel_leftâ‚€ hy0w.ne]
      exact hv2 âŸ¨hzC, hzwâŸ© âŸ¨hy0C, hy0wâŸ©

  -- Convert back to dual p C using hdualC
  simpa [hdualC] using this

private lemma dual_auxGenSet' {C : PointedCone ğ•œ M} (hC : C.FG) :
    dual p (auxGenSet p C w) = span ğ•œ {w} âŠ” dual p C := by
  classical
  apply ge_antisymm
  Â· rw [â† dual_span]
    exact sup_le span_singleton_le_dual_auxGenSet <| dual_le_dual auxGenSet_subset_span
  obtain hSw | hSw := {y âˆˆ C | p y w < 0}.eq_empty_or_nonempty
  Â· -- simp only [Set.sep_eq_empty_iff_mem_false, not_lt] at hSw
    -- exact le_sup_of_le_right <| dual_le_dual fun x hx => .inl âŸ¨hx, hSw _ hxâŸ©
    sorry
  rw [dual_union]
  intro v âŸ¨hv1, hv2âŸ©
  rw [Submodule.mem_sup]
  replace hv2 {x y : M} (hx : x âˆˆ C âˆ§ 0 â‰¤ p x w) (hy : y âˆˆ C âˆ§ p y w < 0) :
      p y w * p x v â‰¤ p y v * p x w := by
    simp only [SetLike.mem_coe, mem_dual, Set.mem_image2, Set.mem_setOf_eq,
      forall_exists_index, and_imp] at hv2
    specialize hv2 x hx.1 hx.2 y hy.1 hy.2 rfl
    simp only [map_sub, map_smul, LinearMap.sub_apply, LinearMap.smul_apply, smul_eq_mul,
      sub_nonneg] at hv2
    nth_rw 2 [mul_comm] at hv2
    exact hv2
  obtain hSv | âŸ¨y, hyâŸ© := {y âˆˆ C | p y w < 0 âˆ§ p y v < 0}.eq_empty_or_nonempty
  Â· simp +contextual only [Set.eq_empty_iff_forall_notMem, Set.mem_setOf_eq, not_and, not_lt] at hSv
    refine âŸ¨0, zero_mem _, v, fun x hx => ?_, zero_add _âŸ©
    by_cases hxw : 0 â‰¤ p x w
    Â· exact hv1 âŸ¨hx, hxwâŸ©
    Â· exact hSv x hx (lt_of_not_ge hxw)
  obtain âŸ¨s, rflâŸ© := hC
  rw [dual_span]
  let u : ğ•œ := ({y âˆˆ s | p y w < 0}.image (fun y => p y v * (p y w)â»Â¹)).max' <| by
    simp
    -- use hSw
    sorry -- simpa [Finset.Nonempty, Set.Nonempty] using hSw
  have hu : 0 â‰¤ u := by
    refine le_trans (mul_nonneg_of_nonpos_of_nonpos hy.2.2.le (inv_nonpos.mpr hy.2.1.le))
      (Finset.le_max' _ (p y v * (p y w)â»Â¹) ?_)
    simp only [Finset.mem_image, Finset.mem_filter]
    exact âŸ¨y, âŸ¨hy.1, hy.2.1âŸ©, rflâŸ©
  refine âŸ¨u â€¢ w, ?_, v - u â€¢ w, fun z hzS â†¦ ?_, add_sub_cancel _ _âŸ©
  Â· rw [â† Nonneg.mk_smul _ hu]
    exact Submodule.smul_mem _ _ (Submodule.subset_span rfl)
  simp only [map_sub, map_smul, smul_eq_mul, sub_nonneg]
  obtain hzw | hzw := lt_or_ge (p z w) 0
  Â· rw [â† _root_.mul_le_mul_right_of_neg (inv_neg''.mpr hzw), mul_inv_cancel_rightâ‚€ hzw.ne]
    exact Finset.le_max' _ (p z v * (p z w)â»Â¹) <|
      Finset.mem_image.mpr âŸ¨z, Finset.mem_filter.mpr âŸ¨hzS, hzwâŸ©, rflâŸ©
  obtain âŸ¨y, hy, t_eq : _ = uâŸ© := Finset.mem_image.mp <|
    ({y âˆˆ s | p y w < 0}.image (fun y => p y v * (p y w)â»Â¹)).max'_mem <| by
      simpa [Finset.Nonempty, Set.Nonempty] using hSw
  rw [Finset.mem_filter] at hy
  rw [â† t_eq, â† _root_.mul_le_mul_left_of_neg hy.2, â† mul_assoc]
  nth_rw 4 [mul_comm]
  rw [mul_inv_cancel_leftâ‚€ hy.2.ne]
  exact hv2 âŸ¨hzS, hzwâŸ© hy

variable (p ğ•œ) in
lemma auxGenSet_eq_dual_inf {C : PointedCone ğ•œ M} (w : N) :
    auxGenSet p C w = (dual p.flip {w} : Set M) âˆ© C := by
  ext x
  simp only [auxGenSet, SetLike.mem_coe, Set.mem_union, Set.mem_setOf_eq, Set.mem_inter_iff,
    mem_dual, Set.mem_singleton_iff, flip_apply, forall_eq]
  constructor
  Â· rintro (âŸ¨xS, pxâŸ© | âŸ¨r, hr, t, ht, rflâŸ©)
    Â· exact âŸ¨px, xSâŸ©
    Â· simp_rw [map_sub, map_smul, sub_apply, smul_apply, smul_eq_mul, mul_comm, sub_self,
      le_refl, true_and, sub_eq_add_neg, â† neg_smul]
      exact C.add_mem (C.smul_mem hr.2 ht.1) <| C.smul_mem (neg_nonneg.mpr (le_of_lt ht.2)) hr.1
  Â· rintro âŸ¨xS, pxâŸ©
    exact Or.inl âŸ¨px, xSâŸ©

lemma auxGenSet_mono (s t : Set M) (hst : s âŠ† t) : auxGenSet p s w âŠ† auxGenSet p t w := by
  -- intro x
  -- simp
  -- rintro (âŸ¨hx, hâŸ© | h)
  -- Â· left; exact âŸ¨hst hx, hâŸ©
  -- right
  -- obtain âŸ¨y, âŸ¨hy, hywâŸ©, z, âŸ¨hz, hzwâŸ©, hâŸ© := h
  -- use y
  -- constructor
  -- Â· exact âŸ¨hst hy, hywâŸ©
  -- use z
  -- Â· exact âŸ¨hst hz, hzwâŸ©
  sorry

lemma span_auxGenSet (s : Set M) :
    span ğ•œ (auxGenSet p s w) = auxGenSet p (span ğ•œ s) w := by
  -- unfold auxGenSet
  -- rw [span_union]
  -- simp
  -- #check mem_span_set
  -- rw [span_image]
  sorry

variable (p ğ•œ) in
lemma span_auxGenSet_eq_dual_inf_span (hs : s.Finite) (w : N) :
    span ğ•œ (auxGenSet p s w) = (dual p.flip {w} : Set M) âˆ© span ğ•œ s := by
  simpa [â† SetLike.coe_set_eq, span_auxGenSet] using auxGenSet_eq_dual_inf _ _ w

------- vvvvvvvv Experiments below

-- There is something that should follow immediately from the above, but does not because
-- the proof looses information about these details. Can we reconstruct it?

variable (p ğ•œ) in
lemma span_auxGenSet_eq_dual_inf_span' (hs : s.Finite) (w : N) :
    span ğ•œ (auxGenSet p s w) = dual p.flip {w} âŠ“ span ğ•œ s := by
  ext x
  simp
  unfold auxGenSet
  rw [span_union]
  rw [mem_sup]
  sorry

variable (p ğ•œ) in
private lemma span_sup_dual_eq_dual_dual_inf_span {C : PointedCone ğ•œ M} (hC : C.FG) (w : N) :
    span ğ•œ {w} âŠ” dual p C = dual p (dual p.flip {w} âˆ© C) := by
  have âŸ¨s, hsâŸ© := hC
  simp [â† hs, â† span_auxGenSet_eq_dual_inf_span, dual_auxGenSet]

variable (p ğ•œ) in
private lemma span_sup_dual_eq_dual_dual_inf_span' {C : PointedCone ğ•œ M} (hC : C.FG) (w : N) :
    span ğ•œ {w} âŠ” dual p C = dual p (dual p.flip {w} âˆ© C) := by
  simp [â† auxGenSet_eq_dual_inf, â† dual_auxGenSet' hC]

variable (p ğ•œ) in
private lemma span_sup_dual_eq_dual_dual_inf_span'' (s : Finset N) (t : Finset M) :
    span ğ•œ s âŠ” dual p t = dual p (dual p.flip s âˆ© span ğ•œ (t : Set M)) := by classical
  induction s using Finset.induction with
  | empty => simp
  | insert w s hwr hs =>
    simp only [Finset.coe_insert, span]
    rw [span_insert, sup_assoc, sup_comm, hs, dual_insert]
    repeat rw [â† Submodule.coe_inf]
    rw [inf_assoc]
    nth_rw 2 [inf_comm]
    -- now use that span R {w} is dual closed.
    sorry

variable (p) in
lemma dual_fg_inf_fgdual_dual_sup_dual' {C D : PointedCone ğ•œ M} (hC : C.FG)
    (hD : D.FGDual p.flip) : dual p (C âˆ© D) = (dual p C) âŠ” (dual p D) := by
  sorry

------- ^^^^^^ Experiments above

/-- The union of an FG cone and a FGDual cone is FGDual. -/
lemma sup_fg_fgdual {C D : PointedCone ğ•œ N} (hC : C.FG) (hD : D.FGDual p) : (C âŠ” D).FGDual p
    := by classical
  obtain âŸ¨s, rflâŸ© := hC
  induction s using Finset.induction with
  | empty => simp [hD]
  | insert w s hws hs =>
    obtain âŸ¨t, htâŸ© := hs
    use (auxGenSet p t.toSet w).toFinset
    simp [span_insert, sup_assoc, â† ht]
    exact dual_auxGenSet t.finite_toSet

lemma sup_fgdual_fg {C D : PointedCone ğ•œ N} (hC : C.FGDual p) (hD : D.FG) : (C âŠ” D).FGDual p
    := by rw [sup_comm]; exact sup_fg_fgdual hD hC

variable (p) [Fact p.SeparatingRight] in
/-- An FG cone can be written as the intersection of a FGDual cone and an FG submodule. -/
lemma FG.exists_fgdual_inf_submodule {C : PointedCone ğ•œ N} (hC : C.FG)
    {S : Submodule ğ•œ N} (hS : S.FG) (hCS : C â‰¤ S) :
      âˆƒ D : PointedCone ğ•œ N, D.FGDual p âˆ§ D âŠ“ S = C := by
  wlog hC' : C = âŠ¥ with h
  Â· specialize h p fg_bot hS bot_le rfl
    obtain âŸ¨D, hfgdual, hDâŸ© := h
    exact âŸ¨_, sup_fg_fgdual hC hfgdual, by simp [â† sup_inf_assoc_of_le_submodule D hCS, hD]âŸ©
  Â· obtain âŸ¨D, hfgdual, hDâŸ© := hS.exists_fgdual_disjoint p  -- <-- submodule duality theory
    exact âŸ¨_, coe_fgdual_iff.mpr hfgdual, by simp [â† restrictScalars_inf, inf_comm, hC', hD.eq_bot]âŸ©

variable (p) [Fact p.SeparatingRight] in
/-- An FG cone can be written as the intersection of its linear span with a FGDual cone. -/
lemma FG.exists_fgdual_inf_span {C : PointedCone ğ•œ N} (hC : C.FG) :
      âˆƒ D : PointedCone ğ•œ N, D.FGDual p âˆ§ D âŠ“ Submodule.span ğ•œ (M := N) C = C :=
  exists_fgdual_inf_submodule p hC (submodule_span_fg hC) Submodule.subset_span

variable (p) [Fact p.SeparatingRight] in
/-- An FG cone can be written as the intersection of a FGDual cone and an FG submodule. -/
lemma FG.exists_fgdual_inf_fg_submodule {C : PointedCone ğ•œ N} (hC : C.FG) :
      âˆƒ D : PointedCone ğ•œ N, D.FGDual p âˆ§ âˆƒ S : Subspace ğ•œ N, S.FG âˆ§ D âŠ“ S = C := by
  obtain âŸ¨D, hfgdual, hDâŸ© := exists_fgdual_inf_span p hC
  exact âŸ¨D, hfgdual, Submodule.span ğ•œ C, submodule_span_fg hC, hDâŸ©

variable (p) [Fact p.SeparatingRight] in
/-- An FG cone is the dual of a FGDual cone. -/
lemma FG.exists_fgdual_dual {C : PointedCone ğ•œ N} (hC : C.FG) :
    âˆƒ D : PointedCone ğ•œ M, D.FGDual p.flip âˆ§ dual p D = C := by
  obtain âŸ¨D, hD, S, hS, rflâŸ© := exists_fgdual_inf_fg_submodule p hC
  obtain âŸ¨C', hfg, rflâŸ© := hD.exists_fg_dual
  use C' âŠ” dual p.flip S
  constructor
  Â· exact sup_fg_fgdual hfg <| fgdual_of_fg p.flip (coe_fg hS)
  Â· rw [dual_sup_dual_inf_dual]
    simp [Submodule.FG.dual_dual_flip _ hS] -- <-- submodule duality theory

@[deprecated FG.exists_fgdual_dual (since := "")]
alias FG.exists_fgdual_flip_dual := FG.exists_fgdual_dual

-- variable (p) [Fact p.flip.IsFaithfulPair] in
-- /-- An FG cone is the dual of a FGDual cone. -/
-- lemma FG.exists_fgdual_dual_flip {C : PointedCone ğ•œ M} (hC : C.FG) :
--     âˆƒ D : PointedCone ğ•œ N, D.FGDual p âˆ§ dual p.flip D = C := exists_fgdual_flip_dual p.flip hC

variable (p) [Fact p.SeparatingRight] in
/-- The double dual of an FG cone is the cone itself. -/
@[simp] lemma FG.dual_dual_flip {C : PointedCone ğ•œ N} (hC : C.FG) : dual p (dual p.flip C) = C := by
  obtain âŸ¨D, hfgdual, rflâŸ© := exists_fgdual_dual p hC
  exact dual_dual_flip_dual (p := p) D

-- NOTE: we keep this flipped version because it is a simp lemma.
variable (p) [Fact p.SeparatingLeft] in
/-- The double dual of an FG cone is the cone itself. -/
@[simp] lemma FG.dual_flip_dual {C : PointedCone ğ•œ M} (hC : C.FG) : dual p.flip (dual p C) = C :=
  FG.dual_dual_flip p.flip hC

variable (p) [Fact p.SeparatingLeft] in
lemma FG.isDualClosed {C : PointedCone ğ•œ M} (hC : C.FG) : C.DualClosed p
    := FG.dual_flip_dual p hC

variable (p) [Fact p.SeparatingRight] in
/-- The double dual of a finite set is its span. -/
@[simp] lemma FG.dual_dual_flip_eq_span (s : Finset N) : dual p (dual p.flip s) = span ğ•œ s := by
  nth_rw 2 [â† dual_span]
  exact dual_dual_flip p (fg_span s.finite_toSet)

-- NOTE: we keep this flipped version because it is a simp lemma.
variable (p) [Fact p.SeparatingLeft] in
/-- The double dual of a finite set is its span. -/
@[simp] lemma FG.dual_flip_dual_eq_span (s : Finset M) : dual p.flip (dual p s) = span ğ•œ s :=
    dual_dual_flip_eq_span p.flip s

variable [Fact p.SeparatingLeft] in
lemma FG.dual_inj {C D : PointedCone ğ•œ M} (hC : C.FG) (hD : D.FG)
    (h : dual p C = dual p D) : C = D := by
  have h := congrArg (dual p.flip) <| congrArg SetLike.coe h
  simpa [dual_flip_dual _ hC, dual_flip_dual _ hD] using h

-- variable [Fact p.IsFaithfulPair] in
-- lemma FG.dual_flip_inj {C D : PointedCone ğ•œ N} (hC : C.FG) (hD : D.FG)
--     (h : dual p.flip C = dual p.flip D) : C = D := dual_inj hC hD h

variable [Fact p.SeparatingLeft] in
@[simp] lemma FG.dual_inj_iff {C D : PointedCone ğ•œ M} (hC : C.FG) (hD : D.FG) :
    dual p C = dual p D â†” C = D := âŸ¨dual_inj hC hD, by simp +contextualâŸ©

-- variable [Fact p.IsFaithfulPair] in
-- @[simp] lemma FG.dual_flip_inj_iff {C D : PointedCone ğ•œ N} (hC : C.FG) (hD : D.FG) :
--     dual p.flip C = dual p.flip D â†” C = D := dual_inj_iff hC hD

variable [Fact p.SeparatingRight] in
/-- The dual of a FGDual cone is FG. -/
lemma FGDual.dual_fg {C : PointedCone ğ•œ M} (hC : C.FGDual p.flip) : (dual p C).FG := by
  obtain âŸ¨D, hfg, rflâŸ© := exists_fg_dual hC
  rw [FG.dual_dual_flip p hfg]
  exact hfg

-- variable [Fact p.flip.IsFaithfulPair] in
-- /-- The dual of a FGDual cone is FG. -/
-- lemma FGDual.dual_flip_fg {C : PointedCone ğ•œ N} (hC : C.FGDual p) :
--    (dual p.flip C).FG := dual_fg hC

/- TODO: For submodules we have an alternative proof that avoids `p.SeparatingRight`.
  Can we have this here as well? -/
variable [Fact p.SeparatingRight] in
lemma FGDual.dual_inf_dual_sup_dual {C D : PointedCone ğ•œ M}
    (hC : C.FGDual p.flip) (hD : D.FGDual p.flip) : dual p (C âˆ© D) = (dual p C) âŠ” (dual p D) := by
  nth_rw 1 [â† FGDual.dual_flip_dual hC, â† FGDual.dual_flip_dual hD,
    â† Submodule.coe_inf, â† dual_sup_dual_inf_dual]
  exact FG.dual_dual_flip p <| sup_fg (FGDual.dual_fg hC) (FGDual.dual_fg hD)


section Module.Finite

variable [Module.Finite ğ•œ N]

variable (p) [Fact p.SeparatingRight] in
/-- A finite dimensional FG cone is also FGDual. -/
lemma FG.fgdual {C : PointedCone ğ•œ N} (hC : C.FG) : C.FGDual p := by
  obtain âŸ¨D, hfgdual, rflâŸ© := exists_fgdual_inf_submodule p hC Finite.fg_top (by simp)
  simpa using hfgdual

/-- A finite dimensional FGDual cone is also FG. -/
lemma FGDual.fg {C : PointedCone ğ•œ N} (hC : C.FGDual p) : C.FG := by
  obtain âŸ¨D, hfg, rflâŸ© := hC.to_id.exists_fg_dual
  exact FGDual.dual_fg <| FG.fgdual _ hfg

variable [Fact p.SeparatingRight] in
/-- A cone in finite dimensional space is FG if and only if it is FGDual. -/
lemma fg_iff_fgdual {C : PointedCone ğ•œ N} : C.FG â†” C.FGDual p := âŸ¨FG.fgdual p, FGDual.fgâŸ©

-- variable [Module.Finite ğ•œ N] in
-- variable [Fact p.IsFaithfulPair] in
-- /-- A finite dimensional cone is FG if and only if it is FGDual. -/
-- lemma fg_iff_fgdual {C : PointedCone ğ•œ N} : C.FGDual p â†” C.FG := âŸ¨FGDual.fg, FG.fgdual pâŸ©

variable (p) in
/-- In finite dimensional space, the dual of and FG cone is itself FG. -/
lemma FG.dual_fg {C : PointedCone ğ•œ M} (hC : C.FG) : (dual p C).FG := by
  rw [dual_id_map]
  exact FGDual.dual_fg <| FG.fgdual _ <| FG.map (LinearMap.restrictScalars _ p) hC

/-- In finite dimensional space, the dual of and FGDual cone is itself FGDual. -/
lemma FGDual.dual_fgdual {C : PointedCone ğ•œ N} (hC : C.FGDual p) : (dual p.flip C).FGDual p.flip
  := FG.dual_fgdual p.flip (FGDual.fg hC)

-- TODO: implement pairing lemmas that allow inference of `Module.Finite ğ•œ M`.
--  We should preferably assume `Module.Finite ğ•œ N`
omit [Module.Finite ğ•œ N] in
variable (p) [Module.Finite ğ•œ M] [Fact p.IsFaithfulPair] in
lemma FG.exists_fg_dual {C : PointedCone ğ•œ N} (hC : C.FG) :
    âˆƒ D : PointedCone ğ•œ M, D.FG âˆ§ dual p D = C := by
  use dual p.flip C
  exact âŸ¨FG.dual_fg p.flip hC, FG.dual_dual_flip p hCâŸ©

end Module.Finite

/- NOTE: the below theorem is the basis for generalizations to certain rings. If R is an
  ordered ring that embeds discretelety in its fraction field (essentually â„¤), then
  intersections of FG cones stay FG (Gordan's lemma).
  recall at https://chatgpt.com/c/691078e5-7f50-8326-8f04-98ae7185da74 -/

/-- The intersection of two FG cones is an FG cone. -/
lemma inf_fg {C D : PointedCone ğ•œ M} (hC : C.FG) (hD : D.FG) : (C âŠ“ D).FG := by
  wlog _ : Module.Finite ğ•œ M with h
  Â· let CD : Submodule ğ•œ M := .span ğ•œ (C âŠ” D : PointedCone ğ•œ M)
    have hCle : C â‰¤ CD := le_submodule_span_of_le le_sup_left
    have hDle : D â‰¤ CD := le_submodule_span_of_le le_sup_right
    specialize h (restrict_fg_of_fg_le hCle hC) (restrict_fg_of_fg_le hDle hD)
      (Finite.iff_fg.mpr <| submodule_span_fg <| sup_fg hC hD)
    rw [â† restrict_inf] at h
    exact fg_of_restrict_le (le_submodule_span_of_le inf_le_sup) h
  Â· exact FGDual.fg <| inf_fgdual (FG.fgdual .id hC) (FG.fgdual .id hD) -- inf_fg' hC hD

/- TODO: the equivalent of the below statement with FGDual instead of FG can likely be proven
  under rather weak assumptions (Noetherian or so). -/

/-- The intersection of an FG cone with an arbitrary submodule is FG. -/
lemma inf_fg_submodule {C : PointedCone ğ•œ M} (hC : C.FG) (S : Submodule ğ•œ M) : (C âŠ“ S).FG := by
  rw [left_eq_inf.mpr (le_submodule_span C), inf_assoc, â† coe_inf]
  exact inf_fg hC <| coe_fg <| FG.of_le (submodule_span_fg hC) inf_le_left

lemma inf_submodule_fg (S : Submodule ğ•œ M) {C : PointedCone ğ•œ M} (hC : C.FG)
    : (S âŠ“ C : PointedCone ğ•œ M).FG := by rw [inf_comm]; exact inf_fg_submodule hC S

/-- The restriction of an FG cone to an arbitrary submodule is FG. -/
lemma FG.restrict_fg (S : Submodule ğ•œ M) {C : PointedCone ğ•œ M} (hC : C.FG) :
    (C.restrict S).FG := by
  rw [restrict_fg_iff_inf_fg]; exact inf_submodule_fg S hC

/-- The intersection of an FG cone and a FGDual cone is FG. -/
lemma inf_fg_fgdual {C D : PointedCone ğ•œ N}
    (hC : C.FG) (hD : D.FGDual p) : (C âŠ“ D).FG := by
  obtain âŸ¨C', hCfgdual, rflâŸ© := FG.exists_fgdual_dual .id hC
  obtain âŸ¨D', hDfg, rflâŸ© := FGDual.exists_fg_dual hD.to_id
  rw [â† dual_sup_dual_inf_dual]
  exact FGDual.dual_fg (sup_fgdual_fg hCfgdual hDfg)

/-- The intersection of a FGDual cone and an FG cone is FG. -/
lemma inf_fgdual_fg {C D : PointedCone ğ•œ N} (hC : C.FGDual p) (hD : D.FG) : (C âŠ“ D).FG
    := by rw [inf_comm]; exact inf_fg_fgdual hD hC

variable (p) in
lemma exists_fg_sup_dual (s : Finset M) :
    âˆƒ D : PointedCone ğ•œ N, D.FG âˆ§ D âŠ” Submodule.dual (R := ğ•œ) p s = dual p s := by
  obtain âŸ¨S, hSâŸ© := Submodule.exists_isCompl (dual p s).lineal
  use (dual p s) âŠ“ S
  constructor
  Â· rw [dual_span_lineal_dual] at hS
    have h := CoFG.fg_of_isCompl hS (dual_finset_cofg p s)
    exact inf_fgdual_fg (fgdual_of_finset p s) (coe_fg h) -- h instead if coe_fg h would work
  Â· rw [â† dual_span_lineal_dual]
    exact inf_sup_lineal hS.codisjoint

variable (p) in
lemma FG.exists_fg_sup_dual {C : PointedCone ğ•œ M} (hC : C.FG) :
    âˆƒ D : PointedCone ğ•œ N, D.FG âˆ§ D âŠ” Submodule.dual (R := ğ•œ) p C = dual p C := by
  obtain âŸ¨s, rflâŸ© := hC
  simpa using PointedCone.exists_fg_sup_dual p s

lemma FGDual.exists_fg_sup_lineal {C : PointedCone ğ•œ N} (hC : C.FGDual p) :
    âˆƒ D : PointedCone ğ•œ N, D.FG âˆ§ D âŠ” C.lineal = C := by
  obtain âŸ¨s, rflâŸ© := hC
  rw [dual_span_lineal_dual]
  exact PointedCone.exists_fg_sup_dual p s

/-- The sum of FGDual cones is FGDual. -/
lemma sup_fgdual {C D : PointedCone ğ•œ N} (hC : C.FGDual p) (hD : D.FGDual p) :
    (C âŠ” D).FGDual p := by
  obtain âŸ¨C', hCfg, hC'âŸ© := hC.exists_fg_sup_lineal
  obtain âŸ¨D', hDfg, hD'âŸ© := hD.exists_fg_sup_lineal
  rw [â† hC', â† hD', sup_assoc]
  nth_rw 2 [sup_comm]
  rw [sup_assoc, â† sup_assoc]
  refine sup_fg_fgdual (sup_fg hCfg hDfg) ?_
  rw [â† coe_sup, coe_fgdual_iff]
  exact Submodule.sup_fgdual hD.lineal_fgdual _  -- <-- submodule duality theory

-- NOTE: Assumption `p.SeparatingLeft` cannot be avoided, see analogous proof for submodules. -/
variable (p) [Fact p.SeparatingLeft] in
lemma FG.dual_inf_dual_sup_dual {C D : PointedCone ğ•œ M} (hC : C.FG) (hD : D.FG) :
    dual p (C âˆ© D) = (dual p C) âŠ” (dual p D) := by
  nth_rw 1 [â† FG.dual_flip_dual p hC, â† FG.dual_flip_dual p hD,
    â† Submodule.coe_inf, â† dual_sup_dual_inf_dual]
  exact FGDual.dual_dual_flip <| sup_fgdual (FG.dual_fgdual p hC) (FG.dual_fgdual p hD)

-- variable [Fact p.flip.IsFaithfulPair] in
-- lemma inf_fgdual_submodule {C : PointedCone ğ•œ N} {S : Submodule ğ•œ N}
--     (hC : C.FGDual p) (hS : S.FG) :
--     (C âŠ“ S).FG := by
--   obtain âŸ¨D, hfg, hDâŸ© := hC.exists_fg_sup_lineal
--   rw [â† hD]
--   rw [â† sup_inf_assoc_of_le_submodule]
--   refine sup_fg hfg ?_
--   rw [â† coe_inf]
--   exact coe_fg (inf_fg_right _ hS)
--   --rw []
--   sorry

/- TODO: For submodules we have an alternative proof that avoids `p.Nondegenerate`.
  Can we have this here as well? -/
variable (p) [Fact p.Nondegenerate] in
lemma dual_fg_inf_fgdual_dual_sup_dual {C D : PointedCone ğ•œ M} (hC : C.FG)
    (hD : D.FGDual p.flip) : dual p (C âˆ© D) = (dual p C) âŠ” (dual p D) := by
  obtain âŸ¨C', hC', rflâŸ© := FG.exists_fgdual_dual p.flip hC
  obtain âŸ¨D', hD', rflâŸ© := FGDual.exists_fg_dual hD
  rw [â† Submodule.coe_inf]
  rw [â† dual_sup_dual_inf_dual]
  rw [flip_flip] at hC'
  rw [FGDual.dual_dual_flip <| sup_fgdual_fg hC' hD']
  rw [FGDual.dual_dual_flip hC']
  rw [FG.dual_dual_flip p hD']

-- -- TODO: Should not need to rely on `p.flip.IsFaithfulPair`. Or maybe actually it should?
-- variable (p) [Fact p.IsFaithfulPair] [Fact p.flip.IsFaithfulPair] in
-- lemma dual_fg_inf_fgdual_dual_sup_dual {C D : PointedCone ğ•œ M} (hC : C.FG)
--     (hD : D.FGDual p.flip) : dual p (C âŠ“ D : PointedCone ğ•œ M) = (dual p C) âŠ” (dual p D) := by
--   obtain âŸ¨C', hC', rflâŸ© := FG.exists_fgdual_dual p.flip hC
--   obtain âŸ¨D', hD', rflâŸ© := FGDual.exists_fg_dual hD
--   rw [â† dual_sup_dual_inf_dual]
--   rw [flip_flip] at hC'
--   rw [FGDual.dual_dual_flip <| sup_fgdual_fg hC' hD']
--   rw [FGDual.dual_dual_flip hC']
--   rw [FG.dual_dual_flip p hD']

lemma dual_fg_inf_submodule_dual_sup_dual {C : PointedCone ğ•œ M} {S : Submodule ğ•œ M}
    (hC : C.FG) (hS : S.FG) :
      dual p (C âŠ“ S : PointedCone ğ•œ M) = (dual p C) âŠ” (dual p S) := by
  sorry

lemma dual_fgdual_inf_submodule_dual_sup_dual {C : PointedCone ğ•œ M} {S : Submodule ğ•œ M}
    (hC : C.FGDual p.flip) (hS : S.FG) :
      dual p (C âŠ“ S : PointedCone ğ•œ M) = (dual p C) âŠ” (dual p S) := by
  sorry

-- TODO: this should *not* rely on `p.flip.IsFaithfulPair`
-- variable (p)[Fact p.flip.IsFaithfulPair] in -- [Fact p.IsFaithfulPair]
-- lemma dual_inf_fgdual_dual_sup_dual {C D : PointedCone ğ•œ M} (hC : C.FG) (hD : D.FG) :
--     dual p (C âŠ“ D : PointedCone ğ•œ M) = (dual p C) âŠ” (dual p D) := by
--   simp
--   exact FG.dual_inf_dual_sup_dual p hC hD
--   -- obtain âŸ¨D', hfgdual, S, hfg, rflâŸ© := FG.exists_fgdual_inf_fg_submodule p.flip hD
--   -- rw [inf_comm, inf_assoc, inf_comm]
--   -- rw [dual_fg_inf_fgdual_dual_sup_dual _ (inf_fg (coe_fg hfg) hC) hfgdual]
--   -- rw [inf_comm]
--   -- rw [dual_fg_inf_submodule_dual_sup_dual hC hfg]
--   -- rw [sup_assoc]; nth_rw 2 [sup_comm]
--   -- rw [â† dual_fgdual_inf_submodule_dual_sup_dual hfgdual hfg]

-- lemma foo (C : PointedCone ğ•œ M) (S : Submodule ğ•œ N) :
--   âˆƒ T : Submodule ğ•œ M, (dual p C).restrict S = dual (Dual.eval ğ•œ T) (C.restrict T) := by sorry

-- private lemma inf_submodule_fgdual (S : Submodule ğ•œ N) {C : PointedCone ğ•œ N} (hC : C.FGDual p) :
--     (C.restrict S).FGDual p := by
--   sorry


-- ----------------- ^^^^^^^ everything up there is proven vvvvv down there is work

-- lemma FG.restrict_fg (S : Submodule ğ•œ M) {C : PointedCone ğ•œ M} (hC : C.FG) : (C.restrict S).FG := by
--   wlog hCS : C â‰¤ S with h
--   Â· let S' : Submodule ğ•œ M := .span ğ•œ C
--     have hCS : C â‰¤ S' := le_submodule_span_self C
--     specialize @h ğ•œ S' _ _ _ _ _ (.restrict S' S) (.restrict S' C)
--       (restrict_fg_of_fg_le hCS hC)
--     sorry -- restrict_mono
--   Â· exact restrict_fg_of_fg_le hCS hC

-- lemma FG.restrict_fg2 (S : Submodule ğ•œ M) {C : PointedCone ğ•œ M} (hC : C.FG) : (C.restrict S).FG := by
--   wlog _ : Module.Finite ğ•œ M with h
--   Â· let S' := Submodule.span ğ•œ (M := M) C
--     specialize @h ğ•œ S' _ _ _ _ _ (.restrict S' S) (restrict S' C) _ _
--     Â· exact restrict_fg_of_fg_le (le_submodule_span_self C) hC
--     Â· exact Finite.iff_fg.mpr (span_fg hC)
--     Â· have hfgS : (restrict S' S).FG := sorry
--       have hfgC : (restrict S' C).FG := sorry
--       sorry
--   Â· exact restrict_fg' S hC

lemma FGDual.exists_fg_sup_submodule {C : PointedCone ğ•œ N} (hC : C.FGDual p)
    {S : Submodule ğ•œ N} (hS : S.FGDual p) (hCS : S â‰¤ C) :
      âˆƒ D : PointedCone ğ•œ N, D.FG âˆ§ D âŠ” S = C := by
  sorry

lemma FGDual.is_dual_finite_inf_span''''' {C : PointedCone ğ•œ N} (hC : C.FG)
    (S : Submodule ğ•œ N) (hFG : S.FG) (hS : C â‰¤ S) : âˆƒ s : Set M, s.Finite âˆ§ dual p s âŠ“ S = C := by
  sorry

lemma FGDual.is_dual_finite_inf_span'''' {C : PointedCone ğ•œ N} (hC : C.FG) :
    âˆƒ s : Set M, s.Finite âˆ§ dual p s âŠ“ Submodule.span (M := N) ğ•œ C = C := by
  sorry

lemma FG.dual_span_finite_sup_lineal (hC : C.FG) :
    âˆƒ s : Set N, s.Finite âˆ§ dual p C = span ğ•œ s âŠ” (dual p C).lineal := by
  sorry

lemma FG.dual_span_finset_sup_lineal (hC : C.FG) :
    âˆƒ s : Finset N, dual p C = span ğ•œ s âŠ” (dual p C).lineal := by
  sorry

lemma FGDual.dual_sup_lineal (hC : C.FG) :
    âˆƒ D : PointedCone ğ•œ N, D.FG âˆ§ dual p C = D âŠ” (dual p C).lineal := by
  sorry

lemma FGDual.is_sup_fgdual_fg (hC : C.FGDual p.flip) :
    âˆƒ D : PointedCone ğ•œ M, D.FG âˆ§ D âŠ” C.lineal = C := by
  sorry

lemma FGDual.lineal_fgdual' (hC : C.FGDual p.flip) : C.lineal.FGDual p.flip := by
  sorry

lemma FG.is_dual_dual_of_finite (hC : C.FG) :
    âˆƒ s : Set M, s.Finite âˆ§ dual p.flip (dual p s) = C := by
  sorry

lemma FG.is_dual_dual_of_fgdual (hC : C.FG) :
    âˆƒ D : PointedCone ğ•œ N, D.FGDual p âˆ§ dual p.flip D = C := by
  sorry

end LinearOrder

end PointedCone
