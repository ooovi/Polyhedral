
import Polyhedral.Polyhedral.Basic
import Polyhedral.Mathlib.Geometry.Convex.Cone.Pointed.Face.Basic
import Polyhedral.Mathlib.Geometry.Convex.Cone.Pointed.Face.Lattice
import Polyhedral.Mathlib.Geometry.Convex.Cone.Pointed.Face.Faces2
import Polyhedral.Mathlib.Geometry.Convex.Cone.Pointed.Face.Exposed
import Polyhedral.Mathlib.Geometry.Convex.Cone.Pointed.Face.FG

namespace PointedCone

open Module Function

/- Wishlist:
 * all faces are polyhedral
 * all faces are exposed
 * there are only finitely many faces
 * salient => generated by its rays
 * duality flips the face lattice
 * face lattice is an abstract polytope
-/

-- ## IS FACE OF

section Ring

variable {R : Type*} [Ring R] [LinearOrder R] [IsOrderedRing R]
variable {M : Type*} [AddCommGroup M] [Module R M]
variable {N : Type*} [AddCommGroup N] [Module R N]
variable {C C₁ C₂ F : PointedCone R M}

-- ...

end Ring

section Field

variable {R : Type*} [Field R] [LinearOrder R] [IsOrderedRing R]
variable {M : Type*} [AddCommGroup M] [Module R M]
variable {N : Type*} [AddCommGroup N] [Module R N]
variable {C C₁ C₂ F F₁ F₂ : PointedCone R M}
variable {p : M →ₗ[R] N →ₗ[R] R}

/- TODO: Many things proven in this section might be true much more generally. Maybe for
  facially exosed cones or something like this:
    * all faces are exposed
    * face lattice of C and C* are anti-isomorphic
    * all faces are duals of faces
    * etc.
-/

-- ## TODO: remove `isPerfPair` from everything below.

variable (p) [p.IsPerfPair] in
-- variable [Fact (Surjective p.flip)] in
@[simp] lemma IsPolyhedral.subdual_subdual (hC : C.IsPolyhedral) (hF : F.IsFaceOf C) :
    subdual p.flip (.dual p C) (subdual p C F) = F := by
  repeat rw [subdual_def]
  rw [dual_flip_dual p hC]
  rw [← dual_span_lineal_dual]
  rw [Submodule.coe_inf, Submodule.coe_restrictScalars]
  nth_rw 3 [← PointedCone.ofSubmodule_coe]
  rw [dual_inf_dual_sup_dual p.flip (hC.dual p) (isPolyhedral_of_submdule _)]
  rw [Submodule.coe_restrictScalars, dual_eq_submodule_dual]
  rw [dual_flip_dual p hC]
  nth_rw 2 [← Submodule.dual_span]
  rw [Submodule.dual_flip_dual p]
  have H : (C ⊔ F.linSpan).lineal = F.linSpan := by
    sorry
  rw [H]
  exact hF.inf_linSpan

/-- Every face of a polyhedral cone is exposed. -/
lemma IsFaceOf.IsPolyhedral.exposed (hC : C.IsPolyhedral) (hF : F.IsFaceOf C) :
    F.IsExposedFaceOf C := by
  wlog h : C.FG with exposed -- reduction to salient case
  · have h' := hF.quot (.lineal C) hF.lineal_le
    rw [IsExposedFaceOf.quot_iff hF (IsFaceOf.lineal C) hF.lineal_le]
    rw [submodule_linSpan] at ⊢ h'
    exact exposed hC.salientQuot h' hC.salientQuot_fg
  exact IsFaceOf.FG.exposed h hF

-- -- TODO: remove the finiteness assumption by reducing to the finite dim case
-- variable [Module.Finite R M] in
-- /-- Every face of a polyhedral cone is exposed. -/
-- lemma IsPolyhedral.face_exposed' (hC : C.IsPolyhedral) (hF : F.IsFaceOf C) :
--     F.IsExposedFaceOf C := by
--   rw [← hC.dual_flip_dual (Dual.eval R M)]
--   rw [← hC.subdual_subdual (Dual.eval R M) hF]
--   exact IsExposedFaceOf.subdual_dual _ <| IsFaceOf.subdual_dual _ hF

-- TODO: weaken p assumption
variable [p.IsPerfPair] in
lemma IsPolyhedral.subdual_inj (hC : C.IsPolyhedral) (hF₁ : F₁.IsFaceOf C) (hF₂ : F₂.IsFaceOf C)
    (h : subdual p C F₁ = subdual p C F₂) : F₁ = F₂ := by
  rw [← hC.subdual_subdual p hF₁]
  rw [← hC.subdual_subdual p hF₂]
  rw [h]

-- TODO: weaken p assumption
variable [p.IsPerfPair] in
lemma IsPolyhedral.IsFaceOf.subdual_of_dual (hC : C.IsPolyhedral) {F : PointedCone R N}
    (hF : F.IsFaceOf (.dual p C)) : (subdual p.flip (.dual p C) F).IsFaceOf C := by
  sorry

/-- The face of a polyhedral one is itself polyhedral. -/
lemma IsPolyhedral.face (hC : C.IsPolyhedral) (hF : F.IsFaceOf C) : F.IsPolyhedral := by
  unfold IsPolyhedral PointedCone.salientQuot
  rw [hF.lineal_eq]
  sorry


-- ## KREIN MILMAN


end Field




-- ## FACE

section Ring

variable {R : Type*} [Ring R] [LinearOrder R] [IsOrderedRing R]
variable {M : Type*} [AddCommGroup M] [Module R M]
variable {N : Type*} [AddCommGroup N] [Module R N]
variable {C C₁ C₂ F : PointedCone R M}

 -- ...

end Ring

section Field

variable {R : Type*} [Field R] [LinearOrder R] [IsOrderedRing R]
variable {M : Type*} [AddCommGroup M] [Module R M]
variable {N : Type*} [AddCommGroup N] [Module R N]
variable {S : Submodule R M}
variable {C C₁ C₂ F : PointedCone R M}
variable {p : M →ₗ[R] N →ₗ[R] R}

lemma IsPolyhedral.exists_fg_combEquiv (hC : C.IsPolyhedral) :
    ∃ D : PointedCone R M, D.FG ∧ D ≃c C := by
  obtain ⟨S, hS⟩ := Submodule.exists_isCompl C.lineal
  exact ⟨_, hC.fg_inf_of_isCompl hS, ⟨inf_combEquiv_of_isCompl_lineal hS.symm⟩⟩

-- ## TODO: remove `isPerfPair` from everything below.

variable [p.IsPerfPair] in
def IsPolyhedral.Face.dual_flip (hC : C.IsPolyhedral) (F : Face (.dual p C)) : Face C :=
    ⟨_, IsFaceOf.subdual_of_dual hC F.isFaceOf⟩

variable (p) [p.IsPerfPair] in
lemma IsPolyhedral.Face.dual_flip_antitone (hC : C.IsPolyhedral) :
    Antitone (dual_flip hC : Face (.dual p C) → Face C) := sorry

variable (p) [p.IsPerfPair] in
lemma IsPolyhedral.Face.dual_flip_strictAnti (hC : C.IsPolyhedral) :
    StrictAnti (dual_flip hC : Face (.dual p C) → Face C) := sorry

variable (p) [p.IsPerfPair] in
lemma IsPolyhedral.Face.dual_strictAnti (hC : C.IsPolyhedral) :
    StrictAnti (.dual p : Face C → Face (.dual p C)) := sorry

variable (p) [p.IsPerfPair] in
lemma IsPolyhedral.Face.dual_le_iff (hC : C.IsPolyhedral) (F₁ F₂ : Face C) :
    F₁.dual p ≤ F₂.dual p ↔ F₁ ≤ F₂ := sorry

variable [p.IsPerfPair] in
lemma IsPolyhedral.Face.dual_flip_le_iff (hC : C.IsPolyhedral) (F₁ F₂ : Face (.dual p C)) :
    dual_flip hC F₂ ≤ dual_flip hC F₁ ↔ F₁ ≤ F₂ := sorry

variable [p.IsPerfPair] in
lemma IsPolyhedral.Face.dual_flip_dual (hC : C.IsPolyhedral) (F : Face C) :
    dual_flip hC (F.dual p) = F := sorry

variable [p.IsPerfPair] in
lemma IsPolyhedral.Face.dual_dual_flip (hC : C.IsPolyhedral) (F : Face (.dual p C)) :
    (dual_flip hC F).dual p = F := sorry

open OrderDual

variable [p.IsPerfPair] in
/-- The face lattice of the dual cone is anti-isomorphic to the face lattice of the cone. -/
def IsPolyhedral.Face.dual_orderIso (hC : C.IsPolyhedral) : Face (.dual p C) ≃o (Face C)ᵒᵈ where
  toFun := toDual ∘ dual_flip hC
  invFun := .dual p ∘ ofDual
  left_inv := dual_dual_flip hC
  right_inv := dual_flip_dual hC
  map_rel_iff' := by intro F₁ F₂; simpa using dual_flip_le_iff hC F₁ F₂

/- TODO:
 * face lattice is graded
-/
instance {C : PolyhedralCone R M} :
    CoeOut (Face (C : PointedCone R M)) (PolyhedralCone R M) where
  coe F := ⟨F, C.isPolyhedral.face F.isFaceOf⟩

instance {C : PolyhedralCone R M} : Finite (Face (C : PointedCone R M)) := sorry

/-- Ideas:
  * `atoms` gives the lowest dimensional non-trivial faces
  * `rays` gives the rays and might be empty
  * a version of Krein-Milman with atoms
  * a version of Krein-Milman for rays if the cone is salient
-/

def atoms : Set (Face (C : PointedCone R M)) := sorry
def rays : Set (Face (C : PointedCone R M)) := sorry

def coatoms : Set (Face (C : PointedCone R M)) := sorry

-- lemma face_exposed (F : Face C) : F.IsExposed := sorry

end Field

end PointedCone
