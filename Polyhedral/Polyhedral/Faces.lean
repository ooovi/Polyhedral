
import Polyhedral.Polyhedral.Basic
import Polyhedral.Mathlib.Geometry.Convex.Cone.Pointed.Face.Basic
import Polyhedral.Mathlib.Geometry.Convex.Cone.Pointed.Face.Faces2
import Polyhedral.Mathlib.Geometry.Convex.Cone.Pointed.Face.Exposed

namespace PointedCone

open Module

/- Wishlist:
 * all faces are polyhedral
 * all faces are exposed
 * there are only finitely many faces
 * salient => generated by its rays
 * duality flips the face lattice
 * face lattice is an abstract polytope
-/

-- ## IS FACE OF

section Ring

variable {R : Type*} [Ring R] [LinearOrder R] [IsOrderedRing R]
variable {M : Type*} [AddCommGroup M] [Module R M]
variable {N : Type*} [AddCommGroup N] [Module R N]
variable {C C₁ C₂ F : PointedCone R M}

-- ...

end Ring

section Field

variable {R : Type*} [Field R] [LinearOrder R] [IsOrderedRing R]
variable {M : Type*} [AddCommGroup M] [Module R M]
variable {N : Type*} [AddCommGroup N] [Module R N]
variable {C C₁ C₂ F F₁ F₂ : PointedCone R M}
variable {p : M →ₗ[R] N →ₗ[R] R}

-- TODO: weaken p assumption
variable (p) [p.IsPerfPair] in
@[simp] lemma IsPolyhedral.subdual_subdual (hC : C.IsPolyhedral) (hF : F.IsFaceOf C) :
    subdual p.flip (PointedCone.dual p C) (subdual p C F) = F := by
  repeat rw [subdual_def]
  rw [dual_flip_dual p hC]
  rw [← dual_span_lineal_dual]
  rw [Submodule.coe_inf, Submodule.coe_restrictScalars]
  nth_rw 3 [← PointedCone.ofSubmodule_coe]
  rw [dual_inf_dual_sup_dual p.flip (hC.dual p) (isPolyhedral_of_submdule _)]
  rw [Submodule.coe_restrictScalars, dual_eq_submodule_dual]
  rw [dual_flip_dual p hC]
  nth_rw 2 [← Submodule.dual_span]
  rw [Submodule.dual_flip_dual p]
  have H : (C ⊔ Submodule.span R (F : Set M)).lineal = Submodule.span R F := by
    sorry
  rw [H]
  exact IsFaceOf.inf_submodule hF

-- TODO: remove the finiteness assumption
variable [Module.Finite R M] in
/-- Every face of a polyhedral cone is exposed. -/
lemma IsPolyhedral.face_exposed (hC : C.IsPolyhedral) (hF : F.IsFaceOf C) :
    F.IsExposedFaceOf C := by
  rw [← hC.dual_flip_dual (Dual.eval R M)]
  rw [← hC.subdual_subdual (Dual.eval R M) hF]
  exact IsExposedFaceOf.subdual_dual _ <| IsFaceOf.subdual_dual _ hF

-- TODO: weaken p assumption
variable [p.IsPerfPair] in
lemma IsPolyhedral.subdual_inj (hC : C.IsPolyhedral) (hF₁ : F₁.IsFaceOf C) (hF₂ : F₂.IsFaceOf C)
    (h : subdual p C F₁ = subdual p C F₂) : F₁ = F₂ := by
  rw [← hC.subdual_subdual p hF₁]
  rw [← hC.subdual_subdual p hF₂]
  rw [h]

/-- The face of a polyhedral one is itself polyhedral. -/
lemma IsPolyhedral.face (hC : C.IsPolyhedral) (hF : F.IsFaceOf C) : F.IsPolyhedral := by
  unfold IsPolyhedral salientQuot
  rw [hF.lineal_eq]
  sorry


-- ## KREIN MILMAN


end Field




-- ## FACE

section Ring

variable {R : Type*} [Ring R] [LinearOrder R] [IsOrderedRing R]
variable {M : Type*} [AddCommGroup M] [Module R M]
variable {N : Type*} [AddCommGroup N] [Module R N]
variable {C C₁ C₂ F : PointedCone R M}

 -- ...

end Ring

section Field

variable {R : Type*} [Field R] [LinearOrder R] [IsOrderedRing R]
variable {M : Type*} [AddCommGroup M] [Module R M]
variable {N : Type*} [AddCommGroup N] [Module R N]
variable {C C₁ C₂ F : PointedCone R M}


/- TODO:
 * face lattice is graded
 * all faces exposed
-/
instance {C : PolyhedralCone R M} :
    CoeOut (Face (C : PointedCone R M)) (PolyhedralCone R M) where
  coe F := ⟨F, C.isPolyhedral.face F.isFaceOf⟩

instance {C : PolyhedralCone R M} : Finite (Face (C : PointedCone R M)) := sorry

/-- Ideas:
  * `atoms` gives the lowest dimensional non-trivial faces
  * `rays` gives the rays and might be empty
  * a version of Krein-Milman with atoms
  * a version of Krein-Milman for rays if the cone is salient
-/

def atoms : Set (Face (C : PointedCone R M)) := sorry
def rays : Set (Face (C : PointedCone R M)) := sorry

def coatoms : Set (Face (C : PointedCone R M)) := sorry

-- lemma face_exposed (F : Face C) : F.IsExposed := sorry

end Field

end PointedCone
