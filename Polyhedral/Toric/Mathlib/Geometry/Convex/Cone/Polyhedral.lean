/-
Copyright (c) 2025 Justus Springer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Justus Springer
-/
import Mathlib.LinearAlgebra.Dual.Defs
import Mathlib.LinearAlgebra.PerfectPairing.Basic
import Mathlib.RingTheory.Finiteness.Basic
import Mathlib.LinearAlgebra.SesquilinearForm

import Polyhedral.Toric.Mathlib.Geometry.Convex.Cone.Dual

/-!
# Polyhedral cones

Given a bilinear pairing `p` between two `R`-modules `M` and `N`, we define
polyhedral cones to be pointed cones in `N` that are the dual of a finite set
in `M` (this means they are the intersection of finitely many halfspaces).

The main statement is that if both `M` and `N` are finite and the pairing is injective
in both arguments, then polyhedral cones are precisely the finitely generated cones, see
`isPolyhedral_iff_fg`. Moreover, we obtain that the dual of a polyhedral cone is again polyhedral
(`IsPolyhedral.dual`) and that the double dual of a polyhedral cone is the cone itself
(`IsPolyhedral.dual_dual_flip`, `IsPolyhedral.dual_flip_dual`).
-/

open Function Module
open Submodule hiding span

variable {ğ•œ M N : Type*}

namespace PointedCone

section LinearOrder

variable [Field ğ•œ] [LinearOrder ğ•œ] [IsStrictOrderedRing ğ•œ] [AddCommGroup M] [AddCommGroup N]
  [Module ğ•œ M] [Module ğ•œ N] {p : M â†’â‚—[ğ•œ] N â†’â‚—[ğ•œ] ğ•œ} {C : PointedCone ğ•œ M} {s : Set M} {w : N}

variable (p s w) in
/-- A set whose dual cone is `span R {w} âŠ” dual p s`, see `dual_sup_span_singleton_eq_dual` -/
private noncomputable abbrev auxGenSet : Set M :=
  {x âˆˆ s | 0 â‰¤ p x w} âˆª
    .image2 (fun x y â†¦ p x w â€¢ y - p y w â€¢ x) {x âˆˆ s | 0 â‰¤ p x w} {y âˆˆ s | p y w < 0}

variable (w) in
omit [IsStrictOrderedRing ğ•œ] in
private lemma auxGenSet_finite (hs : s.Finite) :
    (auxGenSet p s w).Finite := .union (hs.sep _) <| .image2 _ (hs.sep _) (hs.sep _)

private lemma auxGenSet_subset_span :
    (auxGenSet p s w : Set M) âŠ† span ğ•œ (s : Set M) := by
  simp only [Set.union_subset_iff, Set.image2_subset_iff, Set.mem_setOf_eq, and_imp]
  refine âŸ¨subset_trans (fun x hx â†¦ hx.1) subset_span, fun x hxS hxw y hyS hyw â†¦ ?_âŸ©
  simpa [sub_eq_add_neg] using add_mem (smul_mem (span ğ•œ s) âŸ¨p x w, hxwâŸ© (subset_span hyS))
    (smul_mem _ âŸ¨-p y w, neg_nonneg.mpr hyw.leâŸ© (subset_span hxS))

private lemma span_singleton_le_dual_auxGenSet :
    span ğ•œ {w} â‰¤ dual p (auxGenSet p s w) := by
  simp only [span_singleton_le_iff_mem, mem_dual, Set.mem_union, Set.mem_setOf_eq, Set.mem_image2]
  rintro z (hz | âŸ¨x, âŸ¨hxS, hxwâŸ©, y, âŸ¨hyS, hywâŸ©, rflâŸ©)
  Â· exact hz.2
  Â· simp only [map_sub, map_smul, LinearMap.sub_apply, LinearMap.smul_apply, smul_eq_mul,
      sub_nonneg]
    rw [mul_comm]

/-- The crucial lemma in the proof that a finitely generated cone is polyhedral:
The sum of a polyhedral cone and the cone generated by a single ray is again polyhedral. -/
private lemma dual_auxGenSet (hs : s.Finite) :
    dual p (auxGenSet p s w) = span ğ•œ {w} âŠ” dual p s := by
  classical
  apply ge_antisymm
  Â· rw [â† dual_span]
    exact sup_le span_singleton_le_dual_auxGenSet <| dual_le_dual auxGenSet_subset_span
  obtain hSw | hSw := {y âˆˆ s | p y w < 0}.eq_empty_or_nonempty
  Â· simp only [Set.sep_eq_empty_iff_mem_false, not_lt] at hSw
    exact le_sup_of_le_right <| dual_le_dual fun x hx => .inl âŸ¨hx, hSw _ hxâŸ©
  rw [dual_union]
  intro v âŸ¨hv1, hv2âŸ©
  rw [Submodule.mem_sup]
  replace hv2 {x y : M} (hx : x âˆˆ s âˆ§ 0 â‰¤ p x w) (hy : y âˆˆ s âˆ§ p y w < 0) :
      p y w * p x v â‰¤ p y v * p x w := by
    simp only [SetLike.mem_coe, mem_dual, Set.mem_image2, Set.mem_setOf_eq,
      forall_exists_index, and_imp] at hv2
    specialize hv2 x hx.1 hx.2 y hy.1 hy.2 rfl
    simp only [map_sub, map_smul, LinearMap.sub_apply, LinearMap.smul_apply, smul_eq_mul,
      sub_nonneg] at hv2
    nth_rw 2 [mul_comm] at hv2
    exact hv2
  obtain hSv | âŸ¨y, hyâŸ© := {y âˆˆ s | p y w < 0 âˆ§ p y v < 0}.eq_empty_or_nonempty
  Â· simp +contextual only [Set.sep_and, Set.eq_empty_iff_forall_notMem, Set.mem_inter_iff,
      Set.mem_setOf_eq, not_and, true_and, not_lt, and_imp] at hSv
    refine âŸ¨0, zero_mem _, v, fun x hx => ?_, zero_add _âŸ©
    by_cases hxw : 0 â‰¤ p x w
    Â· exact hv1 âŸ¨hx, hxwâŸ©
    Â· exact hSv x hx (lt_of_not_ge hxw)
  lift s to Finset M using hs
  let u : ğ•œ := ({y âˆˆ s | p y w < 0}.image (fun y => p y v * (p y w)â»Â¹)).max' <| by
    simpa [Finset.Nonempty, Set.Nonempty] using hSw.image _
  have hu : 0 â‰¤ u := by
    refine le_trans (mul_nonneg_of_nonpos_of_nonpos hy.2.2.le (inv_nonpos.mpr hy.2.1.le))
      (Finset.le_max' _ (p y v * (p y w)â»Â¹) ?_)
    simp only [Finset.mem_image, Finset.mem_filter]
    exact âŸ¨y, âŸ¨hy.1, hy.2.1âŸ©, rflâŸ©
  refine âŸ¨u â€¢ w, ?_, v - u â€¢ w, fun z hzS â†¦ ?_, add_sub_cancel _ _âŸ©
  Â· rw [â† Nonneg.mk_smul _ hu]
    exact Submodule.smul_mem _ _ (Submodule.subset_span rfl)
  simp only [map_sub, map_smul, smul_eq_mul, sub_nonneg]
  obtain hzw | hzw := lt_or_ge (p z w) 0
  Â· rw [â† _root_.mul_le_mul_right_of_neg (inv_neg''.mpr hzw), mul_inv_cancel_rightâ‚€ hzw.ne]
    exact Finset.le_max' _ (p z v * (p z w)â»Â¹) <|
      Finset.mem_image.mpr âŸ¨z, Finset.mem_filter.mpr âŸ¨hzS, hzwâŸ©, rflâŸ©
  obtain âŸ¨y, hy, t_eq : _ = uâŸ© := Finset.mem_image.mp <|
    ({y âˆˆ s | p y w < 0}.image (fun y => p y v * (p y w)â»Â¹)).max'_mem <| by
      simpa [Finset.Nonempty, Set.Nonempty] using hSw.image _
  rw [Finset.mem_filter] at hy
  rw [â† t_eq, â† _root_.mul_le_mul_left_of_neg hy.2, â† mul_assoc]
  nth_rw 4 [mul_comm]
  rw [mul_inv_cancel_leftâ‚€ hy.2.ne]
  exact hv2 âŸ¨hzS, hzwâŸ© hy

-- variable [AddCommGroup N] [Module ğ•œ N] {p : M â†’â‚—[ğ•œ] N â†’â‚—[ğ•œ] ğ•œ} {s : Set M}
variable (p : M â†’â‚—[ğ•œ] N â†’â‚—[ğ•œ] ğ•œ) [p.IsPerfPair]
variable [Module.Finite ğ•œ N]

lemma FG.exists_finite_dual (hC : C.FG) :
    âˆƒ s : Set N, s.Finite âˆ§ dual p.flip s = C := by
  classical -- for Finset.coe_insert
  obtain âŸ¨s, rflâŸ© := hC
  induction s using Finset.induction with
  | empty =>
    rw [Finset.coe_empty, span_empty]
    obtain âŸ¨s, hsâŸ© := fg_top (R := ğ•œ) (E := N)
    exact âŸ¨s, s.finite_toSet, by rw [â† dual_span, hs]; exact dual_topâŸ©
  | insert w A hwA hA =>
    obtain âŸ¨s, hfin, hsâŸ© := hA
    rw [Finset.coe_insert, span_insert, â† hs, â† dual_auxGenSet hfin]
    exact âŸ¨_, auxGenSet_finite w hfin, rflâŸ©

-- variable (ğ•œ) in
lemma FG.exists_finset_dual (hC : C.FG) :
    âˆƒ s : Finset N, dual p.flip s = C := by
  obtain âŸ¨s, sfin, hsâŸ© := FG.exists_finite_dual p hC
  exact âŸ¨ sfin.toFinset, by simp [hs] âŸ©

-- variable (ğ•œ) in
/-- A finitely generated cone is the dual of a finitely generated cone. -/
lemma FG.exists_fg_dual (hC : C.FG) :
    âˆƒ D : PointedCone ğ•œ N, D.FG âˆ§ dual p.flip D = C := by
  obtain âŸ¨s, hfin, rflâŸ© := FG.exists_finite_dual p hC
  exact âŸ¨ span ğ•œ s, fg_span hfin, dual_span _ âŸ©

variable [Module.Finite ğ•œ M]

omit [Module.Finite ğ•œ N] in
@[simp] lemma FG.dual_dual_flip {C : PointedCone ğ•œ N} (hC : C.FG) :
    dual p (dual p.flip C) = C := by
  obtain âŸ¨s, hs, rflâŸ© := FG.exists_finite_dual p.flip hC; exact dual_dual_flip_dual _

omit [Module.Finite ğ•œ M] in
@[simp] lemma FG.dual_flip_dual {C : PointedCone ğ•œ M} (hC : C.FG) :
  dual p.flip (dual p C) = C := FG.dual_dual_flip p.flip hC

/-- A finitely generated cone is polyhedral. -/
lemma dual.fg_of_fg (hC : C.FG) : (dual p C).FG := by
  obtain âŸ¨D, hfg, rflâŸ© := FG.exists_fg_dual p hC
  rw [FG.dual_dual_flip] <;> exact hfg

omit [Module.Finite ğ•œ N] in
/-- The double dual of a finite set equals the cone generated by that set. -/
lemma dual_dual_flip_eq_span {s : Set N} (hS : s.Finite) :
    dual p (dual p.flip s) = span ğ•œ s := by
  simpa using FG.dual_dual_flip p (Submodule.fg_span hS)

omit [Module.Finite ğ•œ M] in
/-- The double dual of a finite set equals the cone generated by that set. -/
lemma dual_flip_dual_eq_span {s : Set M} (hS : s.Finite) :
    dual p.flip (dual p s) = span ğ•œ s := by
  simpa using FG.dual_dual_flip p.flip (Submodule.fg_span hS)

omit [Module.Finite ğ•œ M] in
lemma FG.dual_inj {Câ‚ Câ‚‚ : PointedCone ğ•œ M} (hCâ‚ : Câ‚.FG) (hCâ‚‚ : Câ‚‚.FG) :
    dual p Câ‚ = dual p Câ‚‚ â†” Câ‚ = Câ‚‚ where
  mp h := by rw [â† FG.dual_flip_dual p hCâ‚, â† FG.dual_flip_dual p hCâ‚‚, h]
  mpr h := by rw [h]

-- lemma dual_inf {C C' : PointedCone ğ•œ M} (hC : C.FG) (hC' : C'.FG) :
--     dual p (C âˆ© C') = dual p C âŠ” dual p C' := by
--   rw [â†FG.dual_inj p.flip]
--   rw [dual_sup]
--   rw [FG.dual_flip_dual]
--   sorry; sorry; sorry; sorry

omit p

/-- A linear subspace is a polyhedral cone -/
lemma IsPolyhedral.submodule (S : Submodule ğ•œ M) : (S : PointedCone ğ•œ M).FG
  := PointedCone.ofSubmodule.FG_of_FG
    <| (Submodule.fg_iff_finiteDimensional S).mpr inferInstance

end LinearOrder


-- Now we are ready to define PolyhedralCone, because from here on we assume V=H.
-- From here on we also mke no use any longer of the precise pairing.

variable [Field ğ•œ] [LinearOrder ğ•œ] [IsStrictOrderedRing ğ•œ] [AddCommGroup M] [AddCommGroup N]
  [Module ğ•œ M] [Module.Finite ğ•œ M]

/-- Abbreviation for PointedCone.FG. Intended for use in contexts with V=H. -/
abbrev IsPolyhedral (C : PointedCone ğ•œ M) := C.FG

-- this definition allows to prove certain statement immediately from FG.
example {C C' : PointedCone ğ•œ M} (hC : C.IsPolyhedral) (hC' : C'.IsPolyhedral) :
    (C âŠ” C').IsPolyhedral := Submodule.FG.sup hC hC'

variable {C C' : PointedCone ğ•œ M} (hC : C.IsPolyhedral) (hC' : C'.IsPolyhedral)

-- lemma dual_inf : PointedCone.dual p (C âŠ“ C') = PointedCone.dual p C âŠ” PointedCone.dual p C' := by
--   -- apply dual_dual_flip_dual
--   sorry

lemma IsPolyhedral.inf : (C âŠ“ C').IsPolyhedral := by
  sorry

end PointedCone

section CommRing

variable [Field ğ•œ] [LinearOrder ğ•œ] [IsStrictOrderedRing ğ•œ] [AddCommGroup M] [AddCommGroup N]
  [Module ğ•œ M] [Module.Finite ğ•œ M]

variable (ğ•œ M) in
structure PolyhedralCone extends PointedCone ğ•œ M where
  isPolyhedral : FG toSubmodule

namespace PolyhedralCone

@[coe] abbrev toPointedCone (C : PolyhedralCone ğ•œ M) : PointedCone ğ•œ M := C.toSubmodule

instance : Coe (PolyhedralCone ğ•œ M) (PointedCone ğ•œ M) where
  coe := toPointedCone

omit [Module.Finite ğ•œ M] in
lemma toPointedCone_injective :
    Injective (toPointedCone : PolyhedralCone ğ•œ M â†’ PointedCone ğ•œ M) :=
  fun âŸ¨_, _âŸ© _ â†¦ by congr!

instance : SetLike (PolyhedralCone ğ•œ M) M where
  coe C := C.toPointedCone
  coe_injective' := SetLike.coe_injective.comp toPointedCone_injective

omit [Module.Finite ğ•œ M] in
@[simp] lemma coe_toPointedCone (C : PolyhedralCone ğ•œ M) : (C.toPointedCone : Set M) = C := rfl

end PolyhedralCone
end CommRing

-- namespace PolyhedralCone

-- variable {R M N : Type*}
--   [CommRing R] [LinearOrder R] [IsStrictOrderedRing R]
--   [AddCommGroup M] [Module R M] [Module.Finite R M] [Projective R M]
--   [AddCommGroup N] [Module R N] -- [Module.Finite ğ•œ M]

-- instance : Bot (PolyhedralCone R M) := âŸ¨âŠ¥, .botâŸ©

-- instance uniqueBot : Unique (âŠ¥ : PolyhedralCone R M) :=
--   inferInstanceAs <| Unique (âŠ¥ : PointedCone R M)

-- instance : Top (PolyhedralCone R M) := âŸ¨ âŠ¤, .top âŸ©

-- instance : Min (PolyhedralCone R M) where
--   min C C' := âŸ¨C âŠ“ C', C.isPolyhedral.inf C'.isPolyhedralâŸ©

-- @[simp, norm_cast] lemma coe_inf (C D : PolyhedralCone R M) :
--     (C âŠ“ D).toPointedCone = C.toPointedCone âŠ“ D.toPointedCone := rfl

-- instance : SemilatticeInf (PolyhedralCone R M) :=
--   PolyhedralCone.toPointedCone_injective.semilatticeInf _ coe_inf

-- -- TODO: add simp lemmas

-- variable {ğ•œ M N : Type*}
--   [Field ğ•œ] [LinearOrder ğ•œ] [IsStrictOrderedRing ğ•œ]
--   [AddCommGroup M] [Module ğ•œ M] [Module.Finite ğ•œ M]
--   [AddCommGroup N] [Module ğ•œ N] -- [Module.Finite ğ•œ M]

-- def of_IsPolyhedral {C : PointedCone ğ•œ M} (hC : C.IsPolyhedral) : PolyhedralCone ğ•œ M := âŸ¨ C, hC âŸ©
-- def of_fg {C : PointedCone ğ•œ M} (hC : C.FG) : PolyhedralCone ğ•œ M := of_IsPolyhedral (.of_fg ğ•œ hC)

-- def span {S : Set M} (hfin : S.Finite) : PolyhedralCone ğ•œ M := of_IsPolyhedral (.span hfin)

-- variable (p : M â†’â‚—[ğ•œ] N â†’â‚—[ğ•œ] ğ•œ) [p.IsPerfPair]

-- def dual (C : PolyhedralCone ğ•œ M) : PolyhedralCone ğ•œ N
--   := âŸ¨PointedCone.dual p C, PointedCone.IsPolyhedral.dual C.isPolyhedralâŸ©

-- def dual_of_finite (S : Set M) (hS : S.Finite) : PolyhedralCone ğ•œ N
--   := âŸ¨PointedCone.dual p S, PointedCone.IsPolyhedral.dual_of_finite hSâŸ©

-- def dual_of_fg (C : PointedCone ğ•œ M) (hC : C.FG) : PolyhedralCone ğ•œ N
--   := âŸ¨PointedCone.dual p C, PointedCone.IsPolyhedral.dual_of_fg hCâŸ©

-- variable [Module.Finite ğ•œ N]
-- variable {p : M â†’â‚—[ğ•œ] N â†’â‚—[ğ•œ] ğ•œ} [p.IsPerfPair]

-- -- probably needs assumptions, such as perfect pairing maybe?
-- lemma dual_dual_flip (C : PolyhedralCone ğ•œ N) : dual p (dual p.flip C) = C := by
--   sorry
-- lemma dual_flip_dual (C : PolyhedralCone ğ•œ M) : dual p.flip (dual p C) = C := by
--   sorry

-- instance : Max (PolyhedralCone ğ•œ M) where
--   max C C' := âŸ¨C âŠ” C', C.isPolyhedral.sup C'.isPolyhedralâŸ©

-- @[simp, norm_cast] lemma coe_sup (C D : PolyhedralCone ğ•œ M) :
--     (C âŠ” D).toPointedCone = C.toPointedCone âŠ” D.toPointedCone := rfl

-- instance : SemilatticeSup (PolyhedralCone ğ•œ M) :=
--   PolyhedralCone.toPointedCone_injective.semilatticeSup _ coe_sup

-- lemma dual_inf {C C' : PolyhedralCone ğ•œ M} : dual p (C âŠ“ C') = dual p C âŠ” dual p C' :=
--   sorry

-- lemma dual_sup {C C' : PolyhedralCone ğ•œ M} : dual p (C âŠ” C') = dual p C âŠ“ dual p C' :=
--   sorry

-- end PolyhedralCone

-- /- Lattice structure -/

-- namespace PolyhedralCone

-- variable [Field ğ•œ] [LinearOrder ğ•œ] [IsOrderedRing ğ•œ] [AddCommGroup M] [Module ğ•œ M] {s : Set (Dual ğ•œ M)} {w : M}

-- def ofSubmodule (S : Submodule ğ•œ M) : PolyhedralCone ğ•œ M := âŸ¨ S, .submodule S âŸ©

-- instance : Coe (Submodule ğ•œ M) (PolyhedralCone ğ•œ M) := âŸ¨ .ofSubmodule âŸ©

-- instance completeLattice : CompleteLattice (PolyhedralCone ğ•œ M) :=
--   { (inferInstance : OrderTop (PolyhedralCone ğ•œ M)),
--     (inferInstance : OrderBot (PolyhedralCone ğ•œ M)) with
--     sup := fun a b â†¦ sInf { x | a â‰¤ x âˆ§ b â‰¤ x }
--     le_sup_left := fun _ _ â†¦ le_sInf' fun _ âŸ¨h, _âŸ© â†¦ h
--     le_sup_right := fun _ _ â†¦ le_sInf' fun _ âŸ¨_, hâŸ© â†¦ h
--     sup_le := fun _ _ _ hâ‚ hâ‚‚ â†¦ sInf_le' âŸ¨hâ‚, hâ‚‚âŸ©
--     inf := (Â· âŠ“ Â·)
--     le_inf := fun _ _ _ â†¦ Set.subset_inter
--     inf_le_left := fun _ _ â†¦ Set.inter_subset_left
--     inf_le_right := fun _ _ â†¦ Set.inter_subset_right
--     sSup S := sInf {sm | âˆ€ s âˆˆ S, s â‰¤ sm}
--     le_sSup := fun _ _ hs â†¦ le_sInf' fun _ hq â†¦ by exact hq _ hs
--     sSup_le := fun _ _ hs â†¦ sInf_le' hs
--     le_sInf := fun _ _ â†¦ le_sInf'
--     sInf_le := fun _ _ â†¦ sInf_le' }

-- end PolyhedralCone


/- What's next:
  * halfspaces
  * intersection/convex hull of PC is PC
  * linear trafo
  * lattice structure
-/
