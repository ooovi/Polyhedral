/-
Copyright (c) 2025 Martin Winter. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Martin Winter
-/
import Mathlib.LinearAlgebra.Dual.Defs
import Mathlib.LinearAlgebra.PerfectPairing.Basic
import Mathlib.RingTheory.Finiteness.Basic
import Mathlib.LinearAlgebra.Quotient.Basic
import Mathlib.Order.Partition.Basic

import Polyhedral.Mathlib.Geometry.Convex.Cone.Pointed.Field
import Polyhedral.ExtremeFaces
import Polyhedral.Halfspace

/-!
# Polyhedral cones

...
-/

/-
Next goal: **Polyhedral Cone decomposition**
 * Over a field every subspace is dual closed, which simplifies some of the below
 * dual closed subspaces are polyhedral cones
 * combiantorial equivalence
 * product face lattices
 * subspaces have only 1 face (and are the only dual closed ones with this property?)
 * if a face lattice is finite, then it is graded?
 * FG cones have graded face lattices
   * if F > G are faces and dim F > dim G + 1, then there is a face in between.
 * ‚àÉ D : PolyhedralCone ùïú M, D.FG ‚àß ‚àÉ S : Submodule ùïú M, S.IsDualClosed .. ‚àß D ‚äî S = C
   * choose S := C.lineal
   * take a subspace T complementary to S
   * set D := C ‚äì T
   * show D is FG
   * theorem: a dual closed cone with finitely many faces and no lineality is FG.
     * there are 1-dimensional faces.
     * idee: the 1-dim faces generate D (Krein-Milmann)
  * Are the following things true for dual closed cones with finite face lattice?
    * Every face is contained in a facet.
    * Every face contains a 1-face.
-/

/- # Strategy:
  * A halfspace has two faces (‚ä• and ‚ä§)
  * Every dual closed cone with two faces (neccessarily ‚ä• and ‚ä§) is a halfspace
  * every face in a halfspace is exposed
  * fibers of exposed faces are exposed
  * intersection of exposed faces is exposed
  * Assume now that C is a dual closed cone with finitely many faces
  * every face lies in a co-atom (just walk up until you find one)
  * Every co-atom is exposed
    * quotient by co-atom
    * the quotient has two faces --> is a halfspace
    * bottom face of halspace is exposed
    * fiber preserves exposed --> co-atom is exposed
  * ?? every face is exposed
    * ?? quotient of a dual closed cone is dual closed?
    * ?? bottom face of a dual closed cone is exposed
    * proceed by induction
      * quotient by any face F (bot face is special case)
      * quotient cone is dual-closed and has finite and smaller face lattice
      * by IH bottom face is exposed
      * fiber of bottom face is F, hence exposed
  * ?? every face is intersection of top face
-/

/- What else we need:
 * how faces transform under maps
   * images of faces are faces of the image (gives a face lattice isom)
   * ...
 * faces lattice of a face of C is a lower interval of face lattice of C
 * projection along a face gives a cone whose face lattice is an upper interval
   of the face lattice of C
 * duality flips the face lattice
 * intervals in a face lattice are a face lattice
 * exposed faces
   * bot and top are exposed
   * if there are finitely many faces, then all faces are exposed
 * projections with FG ker preserve dual closedness
   * how do projections behave under duality
-/

open Function Module OrderDual LinearMap
open Submodule hiding span dual IsDualClosed
open PointedCone


namespace PointedCone

variable {R : Type*} [Field R] [LinearOrder R] [IsOrderedRing R]
variable {M : Type*} [AddCommGroup M] [Module R M]
variable {N : Type*} [AddCommGroup N] [Module R N]
variable {C : PointedCone R M}
variable {p : M ‚Üí‚Çó[R] N ‚Üí‚Çó[R] R}
variable {C C‚ÇÅ C‚ÇÇ F F‚ÇÅ F‚ÇÇ : PointedCone R M}

-- ## IMPORTANT

namespace Face

variable {F F‚ÇÅ F‚ÇÇ : Face C}

@[simp] lemma mem_toPointedCone (x : M) : x ‚àà F ‚Üî x ‚àà F.toPointedCone := .rfl

@[ext] lemma ext (h : ‚àÄ x, x ‚àà F‚ÇÅ ‚Üî x ‚àà F‚ÇÇ) : F‚ÇÅ = F‚ÇÇ := SetLike.ext h

end Face


-- ## MISC

lemma isFaceOf_def :
    F.IsFaceOf C ‚Üî ‚àÄ x ‚àà C, ‚àÄ y ‚àà C, ‚àÄ c : R, c > 0 ‚Üí c ‚Ä¢ x + y ‚àà F ‚Üí x ‚àà F := by sorry

/-- The linear span of the face. -/
abbrev Face.span (F : Face C) : Submodule R M := Submodule.span R F

lemma IsFaceOf.iff_le (h‚ÇÅ : F‚ÇÅ.IsFaceOf C) (h‚ÇÇ : F‚ÇÇ.IsFaceOf C) :
    F‚ÇÅ.IsFaceOf F‚ÇÇ ‚Üî F‚ÇÅ ‚â§ F‚ÇÇ := by
  have h‚ÇÅ' := h‚ÇÅ
  have h‚ÇÇ' := h‚ÇÇ
  rw [isFaceOf_def] at ‚ä¢ h‚ÇÅ h‚ÇÇ
  constructor
  ¬∑ intro h x hx
    sorry
  ¬∑ intro hF x hx y hy c hc hcxy
    specialize h‚ÇÅ x (h‚ÇÇ'.le_self hx)
    sorry

-- Change order of arguments in `IsFaceOf.trans` because currently inconsistent with `embed`?
alias IsFaceOf.embed := IsFaceOf.trans


-- ## DUAL

variable (p) in
/-- The face of the dual cone that corresponds to this face. -/
def Face.dual (F : Face C) : Face (dual p C) := ‚ü®_, F.isFaceOf.subdual_dual p‚ü©

lemma Face.dual_antitone : Antitone (dual p : Face C ‚Üí Face _) := by
  sorry


-- ## RESTRICT / EMBED

lemma IsFaceOf.restrict (h‚ÇÅ : F‚ÇÅ.IsFaceOf C) (h‚ÇÇ : F‚ÇÇ.IsFaceOf C) :
    (F‚ÇÅ ‚äì F‚ÇÇ).IsFaceOf F‚ÇÅ := sorry

def Face.restrict (F‚ÇÅ F‚ÇÇ : Face C) : Face (F‚ÇÅ : PointedCone R M) :=
    ‚ü®F‚ÇÅ ‚äì F‚ÇÇ, F‚ÇÅ.isFaceOf.restrict F‚ÇÇ.isFaceOf‚ü©

def Face.embed {F‚ÇÅ : Face C} (F‚ÇÇ : Face (F‚ÇÅ : PointedCone R M)) : Face C :=
    ‚ü®F‚ÇÇ, F‚ÇÇ.isFaceOf.trans F‚ÇÅ.isFaceOf‚ü©

/-- A face of a face of C coerces to a face of C. -/
instance {F : Face C} : CoeOut (Face (F : PointedCone R M)) (Face C) := ‚ü®Face.embed‚ü©

lemma Face.embed_restrict (F‚ÇÅ F‚ÇÇ : Face C) : embed (F‚ÇÅ.restrict F‚ÇÇ) = F‚ÇÅ ‚äì F‚ÇÇ := rfl

lemma Face.embed_restrict_of_le {F‚ÇÅ F‚ÇÇ : Face C} (hF : F‚ÇÇ ‚â§ F‚ÇÅ) :
    embed (F‚ÇÅ.restrict F‚ÇÇ) = F‚ÇÇ := by simp [embed_restrict, hF]

lemma Face.restrict_embed {F‚ÇÅ : Face C} (F‚ÇÇ : Face (F‚ÇÅ : PointedCone R M)) :
    F‚ÇÅ.restrict (embed F‚ÇÇ) = F‚ÇÇ := by
  unfold restrict embed; congr
  simpa using face_le_self F‚ÇÇ

lemma Face.embed_le {F‚ÇÅ : Face C} (F‚ÇÇ : Face (F‚ÇÅ : PointedCone R M)) : F‚ÇÇ ‚â§ F‚ÇÅ := by
  rw [‚Üê restrict_embed F‚ÇÇ, embed_restrict]
  simp only [inf_le_left]

/-- The isomorphism between a face's face lattice and the interval in the cone's face
 lattice below the face. -/
def Face.orderIso (F : Face C) : Face (F : PointedCone R M) ‚âÉo Set.Icc ‚ä• F where
  toFun G := ‚ü®G, bot_le, Face.embed_le G‚ü©
  invFun G := F.restrict G
  left_inv := restrict_embed
  right_inv G := by simp only [embed_restrict_of_le G.2.2]
  map_rel_iff' := @fun _ _ => by simp [embed]

-- can we get this for free from `Face.orderIso`?
def Face.orderEmbed (F : Face C) : Face (F : PointedCone R M) ‚Ü™o Face C := sorry


-- ## MAP

lemma IsFaceOf.map (f : M ‚Üí‚Çó[R] N) (hf : Injective f) (hF : F.IsFaceOf C) :
    (map f F).IsFaceOf (map f C) := sorry

lemma IsFaceOf.map_iff (f : M ‚Üí‚Çó[R] N) (hf : Injective f) :
    (PointedCone.map f F).IsFaceOf (.map f C) ‚Üî F.IsFaceOf C := sorry

lemma IsFaceOf.map_equiv (e : M ‚âÉ‚Çó[R] N) (hF : F.IsFaceOf C) :
    (PointedCone.map (e : M ‚Üí‚Çó[R] N) F).IsFaceOf (.map e C) :=
  hF.map (e : M ‚Üí‚Çó[R] N) e.injective

def Face.map (f : M ‚Üí‚Çó[R] N) (hf : Injective f) (F : Face C) : Face (map f C)
    := ‚ü®_, F.isFaceOf.map f hf‚ü©

def Face.map_equiv (e : M ‚âÉ‚Çó[R] N) (F : Face C) : Face (PointedCone.map (e : M ‚Üí‚Çó[R] N) C)
    := F.map (e : M ‚Üí‚Çó[R] N) e.injective

lemma Face.map_inj (f : M ‚Üí‚Çó[R] N) (hf : Injective f) :
    Injective (map f hf : Face C ‚Üí Face _) := sorry

def map_face (C : PointedCone R M) (f : M ‚Üí‚Çó[R] N) (hf : Injective f) :
    Face (map f C) ‚âÉo Face C := sorry

def map_face_equiv (C : PointedCone R M) (e : M ‚âÉ‚Çó[R] N) :
    Face (map (e : M ‚Üí‚Çó[R] N) C) ‚âÉo Face C := C.map_face (e : M ‚Üí‚Çó[R] N) e.injective


-- ## QUOT / FIBER

abbrev Face.quotMap (F : Face C) := mkQ F.span

-- def quotBy (C : PointedCone R M) (F : Face C) : PointedCone R (M ‚ß∏ F.span) := map F.quotMap C

/-- The cone obtained by quotiening by the face's linear span. -/
abbrev Face.quot (F : Face C) : PointedCone R (M ‚ß∏ F.span) := .map F.quotMap C

def Face.quotFace (F G : Face C) : Face (F.quot) :=
    ‚ü®F.quot ‚äì PointedCone.map F.quotMap G, by sorry‚ü©

def Face.fiberFace {F : Face C} (G : Face (F.quot)) : Face C :=
    ‚ü®C ‚äì PointedCone.comap F.quotMap G, by sorry‚ü©

/-- Faces of a quotient cone can naturally be considered as faces of the cone. -/
instance {F : Face C} : CoeOut (Face F.quot) (Face C) := ‚ü®Face.fiberFace‚ü©

lemma Face.fiber_quot (F G : Face C) : fiberFace (F.quotFace G) = F ‚äî G := sorry

lemma Face.fiber_quot_of_le {F G : Face C} (h : F ‚â§ G) : fiberFace (F.quotFace G) = G :=
     by simp [fiber_quot, h]

lemma Face.quot_fiber {F : Face C} (G : Face (F.quot)) : F.quotFace (fiberFace G) = G := sorry

lemma Face.le_fiber {F : Face C} (G : Face (F.quot)) : F ‚â§ fiberFace G := sorry

/-- The isomorphism between a quotient's face lattice and the interval in the cone's face
 lattice above the face. -/
def Face.quot_orderIso (F : Face C) : Face F.quot ‚âÉo Set.Icc F ‚ä§ where
  toFun G := ‚ü®G, le_fiber G, le_top‚ü©
  invFun G := F.quotFace G
  left_inv := quot_fiber
  right_inv G := by simp only [fiber_quot_of_le G.2.1]
  map_rel_iff' := by intro G G'; simp; sorry

def Face.quot_orderEmbed (F : Face C) : Face F.quot ‚Ü™o Face C := sorry


-- ## PROD

lemma isFaceOf_prod {C‚ÇÅ C‚ÇÇ F‚ÇÅ F‚ÇÇ : PointedCone R M} :
    F‚ÇÅ.IsFaceOf C‚ÇÅ ‚àß F‚ÇÇ.IsFaceOf C‚ÇÇ ‚Üî IsFaceOf (F‚ÇÅ.prod F‚ÇÇ) (C‚ÇÅ.prod C‚ÇÇ) := sorry

def Face.prod {C‚ÇÅ C‚ÇÇ : PointedCone R M} (F‚ÇÅ : Face C‚ÇÅ) (F‚ÇÇ : Face C‚ÇÇ) : Face (C‚ÇÅ.prod C‚ÇÇ) :=
  ‚ü®_, isFaceOf_prod.mp ‚ü®F‚ÇÅ.isFaceOf, F‚ÇÇ.isFaceOf‚ü©‚ü©

def Face.prod_left {C‚ÇÅ C‚ÇÇ : PointedCone R M} (F : Face (C‚ÇÅ.prod C‚ÇÇ)) : Face C‚ÇÅ := sorry

def Face.prod_right {C‚ÇÅ C‚ÇÇ : PointedCone R M} (F : Face (C‚ÇÅ.prod C‚ÇÇ)) : Face C‚ÇÇ := sorry

lemma Face.prod_prod_left {C‚ÇÅ C‚ÇÇ : PointedCone R M} (F‚ÇÅ : Face C‚ÇÅ) (F‚ÇÇ : Face C‚ÇÇ) :
    (F‚ÇÅ.prod F‚ÇÇ).prod_left = F‚ÇÅ := sorry

lemma Face.prod_prod_right {C‚ÇÅ C‚ÇÇ : PointedCone R M} (F‚ÇÅ : Face C‚ÇÅ) (F‚ÇÇ : Face C‚ÇÇ) :
    (F‚ÇÅ.prod F‚ÇÇ).prod_right = F‚ÇÇ := sorry

def prod_face_orderIso (C : PointedCone R M) (D : PointedCone R N) :
    Face (C.prod D) ‚âÉo Face C √ó Face D := sorry


-- ## SUP

def indep (C D : PointedCone R M) :=
    Disjoint (Submodule.span R C) (Submodule.span R (D : Set M))

-- NOTE: might already exist for submodules
def exists_map_prod_sup (C D : PointedCone R M) (h : C.indep D) :
    ‚àÉ e : M √ó M ‚Üí‚Çó[R] M, Injective e ‚àß map e (C.prod D) = C ‚äî D := sorry

def sup_face_orderIso (C D : PointedCone R M) (h : C.indep D) :
    Face (C ‚äî D) ‚âÉo Face C √ó Face D := sorry

def proper (C : PointedCone R M) :
    PointedCone R (Submodule.span R (C : Set M)) := restrict (Submodule.span (M := M) R C) C

-- def exists_map_prod_sup' (C D : PointedCone R M) (h : C.indep D) :
--     ‚àÉ e : M √ó M ‚âÉ‚Çó[R] M, map e (C.prod D) = C ‚äî D := sorry


-- ## INF

lemma IsFaceOf.inf_cone (h : F‚ÇÅ.IsFaceOf C‚ÇÅ) (C‚ÇÇ : PointedCone R M) :
    (F‚ÇÅ ‚äì C‚ÇÇ).IsFaceOf (C‚ÇÅ ‚äì C‚ÇÇ) := by sorry

def Face.inf_cone (F‚ÇÅ : Face C‚ÇÅ) (C‚ÇÇ : PointedCone R M) : Face (C‚ÇÅ ‚äì C‚ÇÇ)
    := ‚ü®_, F‚ÇÅ.isFaceOf.inf_cone C‚ÇÇ‚ü©

def Face.inf_cone_orderHom (C‚ÇÇ : PointedCone R M) : Face C‚ÇÅ ‚Üío Face (C‚ÇÅ ‚äì C‚ÇÇ) where
  toFun F := F.inf_cone C‚ÇÇ
  monotone' := sorry

lemma IsFaceOf.inf_face (h‚ÇÅ : F‚ÇÅ.IsFaceOf C‚ÇÅ) (h‚ÇÇ : F‚ÇÇ.IsFaceOf C‚ÇÇ) :
    (F‚ÇÅ ‚äì F‚ÇÇ).IsFaceOf (C‚ÇÅ ‚äì C‚ÇÇ) := by sorry

def Face.inf_face (F‚ÇÅ : Face C‚ÇÅ) (F‚ÇÇ : Face C‚ÇÇ) : Face (C‚ÇÅ ‚äì C‚ÇÇ)
    := ‚ü®_, F‚ÇÅ.isFaceOf.inf_face F‚ÇÇ.isFaceOf‚ü©

def Face.inf_face_orderHom (F‚ÇÇ : Face C‚ÇÇ) : Face C‚ÇÅ ‚Üío Face (C‚ÇÅ ‚äì C‚ÇÇ) where
  toFun F := F.inf_face F‚ÇÇ
  monotone' := sorry

def Face.inf_face_orderHom2 : Face C‚ÇÅ √ó Face C‚ÇÇ ‚Üío Face (C‚ÇÅ ‚äì C‚ÇÇ) where
  toFun F := F.1.inf_face F.2
  monotone' := sorry

-- def Face.inf2_left (F : Face (C‚ÇÅ ‚äì C‚ÇÇ)) : Face C‚ÇÅ := sorry -- sInf {F' : Face C‚ÇÅ | F' ‚äì C‚ÇÇ = F }

-- def Face.inf2_right (F : Face (C‚ÇÅ ‚äì C‚ÇÇ)) : Face C‚ÇÇ := sorry

-- lemma Face.inf2_left_right (F : Face (C‚ÇÅ ‚äì C‚ÇÇ)) :
--     inf2 F.inf2_left F.inf2_right = F := sorry


end PointedCone




namespace PointedCone

variable {R : Type*} [Field R] [LinearOrder R] [IsOrderedRing R]
variable {M : Type*} [AddCommGroup M] [Module R M]
variable {N : Type*} [AddCommGroup N] [Module R N]
variable {C : PointedCone R M}
variable {p : M ‚Üí‚Çó[R] N ‚Üí‚Çó[R] R}
variable {C F F‚ÇÅ F‚ÇÇ : PointedCone R M}
variable (hC : C.IsDualClosed p)

def faceSet : Set (Face C) := ‚ä§

variable [Fact p.IsFaithfulPair] in
lemma IsFaceOf.isDualClosed_of_isDualClosed (hF : F.IsFaceOf C) :
    F.IsDualClosed p := by sorry

theorem auxLemma (hC : C.IsDualClosed p) (h : Finite (Face C)) (hlin : C.Salient) :
    C.FG := by sorry

-- ## RELINT

/- A non-topological variant of the relative interior.
  Below two definitions are given. If they are not equivalent, then the more general one should
  be chose and equivalence should be proven when it holds.
-/

def relint (C : PointedCone R M) : ConvexCone R M where
  carrier := {x ‚àà C | ‚àÄ F : Face C, x ‚àà F ‚Üí F = C}
  smul_mem' c hc x hx := by
    constructor
    ¬∑ sorry
    ¬∑ sorry
  add_mem' x hx y hy := by
    simp
    constructor
    ¬∑ sorry
    ¬∑ sorry

theorem relint_def_sInf (C : PointedCone R M) :
    C.relint = sInf {s | dual p.flip (dual p s) = C} := sorry

def min_face {x : M} (h : x ‚àà C) : Face C := sorry -- sInf {F : Face C | x ‚àà F}

theorem relint_def_min (C : PointedCone R M) :
    C.relint = { x ‚àà C | C.min_face (x := x) sorry = C } := sorry

/-- The relative interior is non-empty. -/
lemma relint_nonempty (C : PointedCone R M) : C.relint ‚â† ‚ä• := sorry

/-- The relative interior is non-empty. -/
lemma relint_nonempty' (C : PointedCone R M) : Nonempty C.relint := sorry

lemma relint_disj (F‚ÇÅ F‚ÇÇ : Face C) :
    F‚ÇÅ ‚â† F‚ÇÇ ‚Üî Disjoint (relint F‚ÇÅ) (relint F‚ÇÇ) (Œ± := ConvexCone R M) := sorry

lemma relint_cover (C : PointedCone R M) :
    ‚ãÉ‚ÇÄ ((SetLike.coe ‚àò relint ‚àò Face.toPointedCone) '' C.faceSet) = C := sorry

def relint_partition (C : PointedCone R M) : Partition (C : Set M) where
  parts := { relint (F : PointedCone R M) | (F : Face C) }
  sSupIndep' := sorry
  bot_notMem' := by
    simp only [Set.bot_eq_empty, Set.mem_setOf_eq, ConvexCone.coe_eq_empty, not_exists]
    exact fun F => relint_nonempty (F : PointedCone R M)
  sSup_eq' := by
    ext x
    -- simp; exact relint_partition C
    sorry

-- ## EXPOSED

def HalfspaceOrTop.IsSupportAt (H : HalfspaceOrTop R M) (F : Face C) :=
    C ‚â§ H ‚àß C ‚äì H.boundary = F

def HyperplaneOrTop.IsSupportAt (H : HyperplaneOrTop R M) (F : Face C) :=
    ‚àÉ H' : HalfspaceOrTop R M, H'.boundary = H ‚àß C ‚â§ H' ‚àß C ‚äì H = F

def Face.IsExposed (F : Face C) := ‚àÉ H : HalfspaceOrTop R M, H.IsSupportAt F
-- def Face.IsExposed (F : Face C) := ‚àÉ H : HalfspaceOrTop R M, C ‚â§ H ‚àß C ‚äì H.boundary = F

lemma Face.isExpose_def (F : Face C) :
    F.IsExposed ‚Üî ‚àÉ œÜ : M ‚Üí‚Çó[R] R, (‚àÄ x ‚àà C, œÜ x ‚â• 0) ‚àß (‚àÄ x ‚àà C, œÜ x = 0 ‚Üî x ‚àà F) := sorry

theorem bot_isExposed (hC : C.IsDualClosed p) : (‚ä• : Face C).IsExposed := by
  -- reduce to salient case via quotients
  wlog h : C.Salient
  ¬∑ sorry
  rw [Face.isExpose_def]
  have hC : C.IsDualClosed (Dual.eval R M) := hC.to_eval
  obtain ‚ü®D, hD, hDC‚ü© := hC.exists_of_dual_flip
  let œÜ := D.relint_nonempty'.some
  use œÜ
  constructor
  ¬∑ sorry
  ¬∑ sorry

theorem IsExposed.of_isExposed_face_quot {F : Face C} {G : Face (F.quot)} (hG : G.IsExposed) :
    F.IsExposed := by
  -- idea: the comap of a supporting halfspace is again a supporting halfspace.
  sorry

theorem IsDualClosed.quot (hC : C.IsDualClosed p) (F : Face C) :
    F.quot.IsDualClosed (Dual.eval R (M ‚ß∏ F.span)) := sorry

end PointedCone



namespace Submodule

variable {R : Type*} [Semiring R] [LinearOrder R] [IsOrderedRing R]
variable {M : Type*} [AddCommGroup M] [Module R M]
variable {N : Type*} [AddCommGroup N] [Module R N]

lemma face_eq_top {S : Submodule R M} {F : PointedCone R M} (hF : F.IsFaceOf S) :
    F = S := by sorry

lemma Face.eq_top {S : Submodule R M} (F : Face (S : PointedCone R M)) :
    F = ‚ä§ := by sorry

instance face_unique {S : Submodule R M} : Unique (Face (S : PointedCone R M)) where
  default := ‚ä§
  uniq F := Submodule.Face.eq_top F

variable {R : Type*} [Field R] [LinearOrder R] [IsOrderedRing R]
variable {M : Type*} [AddCommGroup M] [Module R M]
variable {N : Type*} [AddCommGroup N] [Module R N]
variable {C : PointedCone R M}

lemma face_bot_eq_top {S : Submodule R M} : (‚ä• : Face (S : PointedCone R M)) = ‚ä§ := by sorry

end Submodule
