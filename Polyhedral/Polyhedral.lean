/-
Copyright (c) 2025 Martin Winter. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Martin Winter
-/
import Mathlib.LinearAlgebra.Dual.Defs
import Mathlib.LinearAlgebra.PerfectPairing.Basic
import Mathlib.RingTheory.Finiteness.Basic
import Mathlib.LinearAlgebra.Quotient.Basic
import Mathlib.Order.Partition.Basic

import Polyhedral.Mathlib.Geometry.Convex.Cone.Pointed.Field
import Polyhedral.ExtremeFaces
import Polyhedral.Faces2
import Polyhedral.Halfspace

/-!
# Polyhedral cones

...
-/


/- Next goal: **FG cones are polyhedral**
 * FG cones are dual closed (check)
 * Submodule has a single face
 * face lattice of product is product of face lattices
 * â†’ If C âŠ“ S = âŠ¥, then C âŠ” S has the same face lattice as C
 * (M) Every cone C can be written as C = C' + C.lineal, with C pointed and complementary
 * If C is pointy and dual closed, then generated by 1-dim faces.
 * Every face of C is generated by a subset of the generators of C
   *
 * FG have finitely many faces
   * every face of C is generated by a subset of the generators of C
   * only finitly many subsets of the generators of C â†’ only finitely many faces of C
 * dual of a dual closed cone has opposite face lattice
 * face lattice graded (when??)
-/


variable {ğ•œ M N : Type*}

variable [Field ğ•œ] [LinearOrder ğ•œ] [IsStrictOrderedRing ğ•œ]
variable [AddCommGroup M] [AddCommGroup M] [Module ğ•œ M]
variable [AddCommGroup N] [AddCommGroup N] [Module ğ•œ N]
-- variable [AddCommGroup N] [AddCommGroup N] [Module ğ•œ N]

-- /-- A cone is polyhedral if it is dual closed and has finitely many faces. -/
-- structure PointedCone.IsPolyhedral (C : PointedCone ğ•œ M) where
--   finite := Finite (Face C)
--   closed := C.IsDualClosed

variable (ğ•œ M) in
/-- A polyhedral cone is a dual closed cone with finitely many faces. -/
structure PolyhedralCone extends PointedCone ğ•œ M where
  /-- A polyhedral cone has finitely many faces. -/
  finiteFaces : Finite (Face toSubmodule)
  /-- A polyhedral cone is dual closed. -/
  dualClosed : IsDualClosed (Dual.eval ğ•œ M) toSubmodule

namespace PolyhedralCone

@[coe] abbrev toPointedCone (C : PolyhedralCone ğ•œ M) : PointedCone ğ•œ M := C.toSubmodule

instance : Coe (PolyhedralCone ğ•œ M) (PointedCone ğ•œ M) where
  coe := toPointedCone

lemma toPointedCone_injective :
    Injective (toPointedCone : PolyhedralCone ğ•œ M â†’ PointedCone ğ•œ M) :=
  sorry -- fun âŸ¨_, _âŸ© _ â†¦ by congr!

lemma foo (C : PolyhedralCone ğ•œ M) :
  âˆƒ D : PolyhedralCone ğ•œ M, D.FG âˆ§ âˆƒ S : Submodule ğ•œ M, S.IsDualClosed (Dual.eval ğ•œ M) âˆ§ D âŠ” S = C
  := sorry

variable [Module.Finite ğ•œ M]

instance : SetLike (PolyhedralCone ğ•œ M) M where
  coe C := C.toPointedCone
  coe_injective' := SetLike.coe_injective.comp toPointedCone_injective

@[simp] lemma coe_toPointedCone (C : PolyhedralCone ğ•œ M) : (C.toPointedCone : Set M) = C := rfl

--------------------------

def of_FG {C : PointedCone ğ•œ M} (hC : C.FG) : PolyhedralCone ğ•œ M
    := âŸ¨C, Face.finite_of_fg hC, FG.isDualClosed (Dual.eval ğ•œ M) hCâŸ©

def span (s : Finset M) : PolyhedralCone ğ•œ M := of_FG (Submodule.fg_span <| s.finite_toSet)

def span_of_finite {S : Set M} (hfin : S.Finite) : PolyhedralCone ğ•œ M
  := of_FG (Submodule.fg_span hfin)

instance {C : PolyhedralCone ğ•œ M} :
    CoeOut (PointedCone.Face (C : PointedCone ğ•œ M)) (PolyhedralCone ğ•œ M) := sorry

instance : Coe (Submodule ğ•œ M) (PolyhedralCone ğ•œ M) := sorry

instance : Bot (PolyhedralCone ğ•œ M) := âŸ¨of_FG fg_botâŸ©
instance : Top (PolyhedralCone ğ•œ M) := âŸ¨of_FG Module.Finite.fg_topâŸ©

instance : OrderBot (PolyhedralCone ğ•œ M) := âŸ¨sorryâŸ©
instance : OrderTop (PolyhedralCone ğ•œ M) := âŸ¨sorryâŸ©

instance : Min (PolyhedralCone ğ•œ M) where
  min C D := sorry -- of_FG <| PointedCone.inf_fg C.isFG D.isFG
instance : Max (PolyhedralCone ğ•œ M) where
  max C D := sorry -- of_FG <| PointedCone.sup_fg C.isFG D.isFG
-- NOTE: on cones, âŠ” also acts as Minkowski sum

variable {ğ•œ M N : Type*}
variable [Field ğ•œ] [LinearOrder ğ•œ] [IsStrictOrderedRing ğ•œ]
variable [AddCommGroup M] [Module ğ•œ M]
variable [AddCommGroup N] [Module ğ•œ N]
variable {p : M â†’â‚—[ğ•œ] N â†’â‚—[ğ•œ] ğ•œ}

theorem isDualClosed_iff_isDualClosed_lineal (P : PolyhedralCone ğ•œ M) :
  IsDualClosed p P â†” Submodule.IsDualClosed p (lineal P) := by sorry



def of_CoFG {C : PointedCone ğ•œ N} (hC : C.CoFG p) : PolyhedralCone ğ•œ N
    := âŸ¨C, by sorry, by sorryâŸ©

variable (p) in
def dual (C : PolyhedralCone ğ•œ M) : PolyhedralCone ğ•œ N
  := sorry -- of_FG (PointedCone.dual_fg p C.isFG)

def dual_of_fg (C : PointedCone ğ•œ M) (hC : C.FG) : PolyhedralCone ğ•œ N
  := sorry -- dual p (of_FG hC)

def dual_of_finset (s : Finset M) : PolyhedralCone ğ•œ N
  := sorry -- dual p (of_FG <| Submodule.fg_span s.finite_toSet)

def dual_of_finite (S : Set M) (hS : S.Finite) : PolyhedralCone ğ•œ N
  := sorry -- dual p (of_FG <| Submodule.fg_span hS)

variable [Module.Finite ğ•œ N]
variable {p : M â†’â‚—[ğ•œ] N â†’â‚—[ğ•œ] ğ•œ} [p.IsPerfPair]

-- probably needs assumptions, such as perfect pairing maybe?
lemma dual_dual_flip (C : PolyhedralCone ğ•œ N) : dual p (dual p.flip C) = C := by
  sorry
lemma dual_flip_dual (C : PolyhedralCone ğ•œ M) : dual p.flip (dual p C) = C := by
  sorry

section Map

variable {ğ•œ : Type*} [Semiring ğ•œ] [PartialOrder ğ•œ] [IsOrderedRing ğ•œ]
variable {M N M' N' : Type*}
  [AddCommMonoid M] [Module ğ•œ M]
  -- [AddCommGroup N] [Module ğ•œ N]
  [AddCommMonoid M'] [Module ğ•œ M'] [Module.Finite ğ•œ M']
  -- [AddCommGroup N'] [Module ğ•œ N'] [Module.Finite ğ•œ N']

variable (f : M â†’â‚—[ğ•œ] M')

theorem _root_.Submodule.FG.comap {S : Submodule ğ•œ M'} (hs : S.FG) : (S.comap f).FG := by
  sorry

variable {ğ•œ : Type*} [Field ğ•œ] [LinearOrder ğ•œ] [IsStrictOrderedRing ğ•œ]
variable {M N M' N' : Type*}
  [AddCommGroup M] [Module ğ•œ M]
  -- [AddCommGroup N] [Module ğ•œ N]
  [AddCommGroup M'] [Module ğ•œ M'] [Module.Finite ğ•œ M']
  -- [AddCommGroup N'] [Module ğ•œ N'] [Module.Finite ğ•œ N']

variable (f : M â†’â‚—[ğ•œ] M')

def map (C : PolyhedralCone ğ•œ M) : PolyhedralCone ğ•œ M'
  := of_FG <| Submodule.FG.map (f.restrictScalars _) C.isFG

local notation3 "ğ•œâ‰¥0" => {c : ğ•œ // 0 â‰¤ c}

def comap (C : PolyhedralCone ğ•œ M') : PolyhedralCone ğ•œ M
  := of_FG <| Submodule.FG.comap (f.restrictScalars _) C.isFG

variable [Module.Finite ğ•œ M]

lemma map_dual (C : PolyhedralCone ğ•œ M) :
    dual (Dual.eval ğ•œ M') (map f C) = comap f.dualMap (dual (Dual.eval ğ•œ M) C) := by
  sorry -- ext x; simp

instance : Neg (PolyhedralCone ğ•œ M) where
  neg C := of_FG <| Submodule.FG.map (-.id) C.isFG

instance : Coe (Submodule ğ•œ M) (PolyhedralCone ğ•œ M) where
  coe S := of_FG <| PointedCone.ofSubmodule_fg_of_fg
    <| (Submodule.fg_iff_finiteDimensional S).mpr inferInstance


-- /-- A linear subspace is a polyhedral cone -/
-- lemma IsPolyhedral.submodule (S : Submodule ğ•œ M) : (S : PointedCone ğ•œ M).FG
--   := PointedCone.ofSubmodule.FG_of_FG
--     <| (Submodule.fg_iff_finiteDimensional S).mpr inferInstance

end Map

end PolyhedralCone

-- namespace PolyhedralCone

-- variable {R M N : Type*}
--   [CommRing R] [LinearOrder R] [IsStrictOrderedRing R]
--   [AddCommGroup M] [Module R M] [Module.Finite R M] [Projective R M]
--   [AddCommGroup N] [Module R N] -- [Module.Finite ğ•œ M]

-- instance : Bot (PolyhedralCone R M) := âŸ¨âŠ¥, .botâŸ©

-- instance uniqueBot : Unique (âŠ¥ : PolyhedralCone R M) :=
--   inferInstanceAs <| Unique (âŠ¥ : PointedCone R M)

-- instance : Top (PolyhedralCone R M) := âŸ¨ âŠ¤, .top âŸ©

-- instance : Min (PolyhedralCone R M) where
--   min C C' := âŸ¨C âŠ“ C', C.isPolyhedral.inf C'.isPolyhedralâŸ©

-- @[simp, norm_cast] lemma coe_inf (C D : PolyhedralCone R M) :
--     (C âŠ“ D).toPointedCone = C.toPointedCone âŠ“ D.toPointedCone := rfl

-- instance : SemilatticeInf (PolyhedralCone R M) :=
--   PolyhedralCone.toPointedCone_injective.semilatticeInf _ coe_inf

-- -- TODO: add simp lemmas

-- variable {ğ•œ M N : Type*}
--   [Field ğ•œ] [LinearOrder ğ•œ] [IsStrictOrderedRing ğ•œ]
--   [AddCommGroup M] [Module ğ•œ M] [Module.Finite ğ•œ M]
--   [AddCommGroup N] [Module ğ•œ N] -- [Module.Finite ğ•œ M]

-- def of_IsPolyhedral {C : PointedCone ğ•œ M} (hC : C.IsPolyhedral) : PolyhedralCone ğ•œ M := âŸ¨ C, hC âŸ©
-- def of_fg {C : PointedCone ğ•œ M} (hC : C.FG) : PolyhedralCone ğ•œ M := of_IsPolyhedral (.of_fg ğ•œ hC)

-- def span {S : Set M} (hfin : S.Finite) : PolyhedralCone ğ•œ M := of_IsPolyhedral (.span hfin)

-- variable (p : M â†’â‚—[ğ•œ] N â†’â‚—[ğ•œ] ğ•œ) [p.IsPerfPair]
-- variable [Module.Finite ğ•œ N]
-- variable {p : M â†’â‚—[ğ•œ] N â†’â‚—[ğ•œ] ğ•œ} [p.IsPerfPair]

-- instance : Max (PolyhedralCone ğ•œ M) where
--   max C C' := âŸ¨C âŠ” C', C.isPolyhedral.sup C'.isPolyhedralâŸ©

-- @[simp, norm_cast] lemma coe_sup (C D : PolyhedralCone ğ•œ M) :
--     (C âŠ” D).toPointedCone = C.toPointedCone âŠ” D.toPointedCone := rfl

-- instance : SemilatticeSup (PolyhedralCone ğ•œ M) :=
--   PolyhedralCone.toPointedCone_injective.semilatticeSup _ coe_sup

-- lemma dual_inf {C C' : PolyhedralCone ğ•œ M} : dual p (C âŠ“ C') = dual p C âŠ” dual p C' :=
--   sorry

-- lemma dual_sup {C C' : PolyhedralCone ğ•œ M} : dual p (C âŠ” C') = dual p C âŠ“ dual p C' :=
--   sorry

-- end PolyhedralCone

-- /- Lattice structure -/

-- namespace PolyhedralCone

-- variable [Field ğ•œ] [LinearOrder ğ•œ] [IsOrderedRing ğ•œ] [AddCommGroup M] [Module ğ•œ M] {s : Set (Dual ğ•œ M)} {w : M}

-- def ofSubmodule (S : Submodule ğ•œ M) : PolyhedralCone ğ•œ M := âŸ¨ S, .submodule S âŸ©

-- instance : Coe (Submodule ğ•œ M) (PolyhedralCone ğ•œ M) := âŸ¨ .ofSubmodule âŸ©

-- instance completeLattice : CompleteLattice (PolyhedralCone ğ•œ M) :=
--   { (inferInstance : OrderTop (PolyhedralCone ğ•œ M)),
--     (inferInstance : OrderBot (PolyhedralCone ğ•œ M)) with
--     sup := fun a b â†¦ sInf { x | a â‰¤ x âˆ§ b â‰¤ x }
--     le_sup_left := fun _ _ â†¦ le_sInf' fun _ âŸ¨h, _âŸ© â†¦ h
--     le_sup_right := fun _ _ â†¦ le_sInf' fun _ âŸ¨_, hâŸ© â†¦ h
--     sup_le := fun _ _ _ hâ‚ hâ‚‚ â†¦ sInf_le' âŸ¨hâ‚, hâ‚‚âŸ©
--     inf := (Â· âŠ“ Â·)
--     le_inf := fun _ _ _ â†¦ Set.subset_inter
--     inf_le_left := fun _ _ â†¦ Set.inter_subset_left
--     inf_le_right := fun _ _ â†¦ Set.inter_subset_right
--     sSup S := sInf {sm | âˆ€ s âˆˆ S, s â‰¤ sm}
--     le_sSup := fun _ _ hs â†¦ le_sInf' fun _ hq â†¦ by exact hq _ hs
--     sSup_le := fun _ _ hs â†¦ sInf_le' hs
--     le_sInf := fun _ _ â†¦ le_sInf'
--     sInf_le := fun _ _ â†¦ sInf_le' }

-- end PolyhedralCone
