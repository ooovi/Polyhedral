/-
Copyright (c) 2025 Martin Winter. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Martin Winter
-/
import Mathlib.LinearAlgebra.Dual.Defs
import Mathlib.LinearAlgebra.PerfectPairing.Basic
import Mathlib.RingTheory.Finiteness.Basic
import Mathlib.LinearAlgebra.Quotient.Basic
import Mathlib.Order.Partition.Basic

import Polyhedral.Mathlib.Geometry.Convex.Cone.Pointed.Field
import Polyhedral.ExtremeFaces
import Polyhedral.Faces2
import Polyhedral.Halfspace

/-!
# Polyhedral cones

...
-/


/- Next goal: **FG cones are polyhedral**
 * FG cones are dual closed (check)
 * Submodule has a single face
 * face lattice of product is product of face lattices
 * → If C ⊓ S = ⊥, then C ⊔ S has the same face lattice as C
 * (M) Every cone C can be written as C = C' + C.lineal, with C pointed and complementary
 * If C is pointy and dual closed, then generated by 1-dim faces.
 * Every face of C is generated by a subset of the generators of C
   *
 * FG have finitely many faces
   * every face of C is generated by a subset of the generators of C
   * only finitly many subsets of the generators of C → only finitely many faces of C
 * dual of a dual closed cone has opposite face lattice
 * face lattice graded (when??)
-/


variable {𝕜 M N : Type*}

variable [Field 𝕜] [LinearOrder 𝕜] [IsStrictOrderedRing 𝕜]
variable [AddCommGroup M] [AddCommGroup M] [Module 𝕜 M]
variable [AddCommGroup N] [AddCommGroup N] [Module 𝕜 N]
-- variable [AddCommGroup N] [AddCommGroup N] [Module 𝕜 N]

-- /-- A cone is polyhedral if it is dual closed and has finitely many faces. -/
-- structure PointedCone.IsPolyhedral (C : PointedCone 𝕜 M) where
--   finite := Finite (Face C)
--   closed := C.IsDualClosed

variable (𝕜 M) in
/-- A polyhedral cone is a dual closed cone with finitely many faces. -/
structure PolyhedralCone extends PointedCone 𝕜 M where
  /-- A polyhedral cone has finitely many faces. -/
  finiteFaces : Finite (Face toSubmodule)
  /-- A polyhedral cone is dual closed. -/
  dualClosed : IsDualClosed (Dual.eval 𝕜 M) toSubmodule

namespace PolyhedralCone

@[coe] abbrev toPointedCone (C : PolyhedralCone 𝕜 M) : PointedCone 𝕜 M := C.toSubmodule

instance : Coe (PolyhedralCone 𝕜 M) (PointedCone 𝕜 M) where
  coe := toPointedCone

lemma toPointedCone_injective :
    Injective (toPointedCone : PolyhedralCone 𝕜 M → PointedCone 𝕜 M) :=
  sorry -- fun ⟨_, _⟩ _ ↦ by congr!

lemma foo (C : PolyhedralCone 𝕜 M) :
  ∃ D : PolyhedralCone 𝕜 M, D.FG ∧ ∃ S : Submodule 𝕜 M, S.IsDualClosed (Dual.eval 𝕜 M) ∧ D ⊔ S = C
  := sorry

variable [Module.Finite 𝕜 M]

instance : SetLike (PolyhedralCone 𝕜 M) M where
  coe C := C.toPointedCone
  coe_injective' := SetLike.coe_injective.comp toPointedCone_injective

@[simp] lemma coe_toPointedCone (C : PolyhedralCone 𝕜 M) : (C.toPointedCone : Set M) = C := rfl

--------------------------

def of_FG {C : PointedCone 𝕜 M} (hC : C.FG) : PolyhedralCone 𝕜 M
    := ⟨C, Face.finite_of_fg hC, FG.isDualClosed (Dual.eval 𝕜 M) hC⟩

def span (s : Finset M) : PolyhedralCone 𝕜 M := of_FG (Submodule.fg_span <| s.finite_toSet)

def span_of_finite {S : Set M} (hfin : S.Finite) : PolyhedralCone 𝕜 M
  := of_FG (Submodule.fg_span hfin)

instance {C : PolyhedralCone 𝕜 M} :
    CoeOut (PointedCone.Face (C : PointedCone 𝕜 M)) (PolyhedralCone 𝕜 M) := sorry

instance : Coe (Submodule 𝕜 M) (PolyhedralCone 𝕜 M) := sorry

instance : Bot (PolyhedralCone 𝕜 M) := ⟨of_FG fg_bot⟩
instance : Top (PolyhedralCone 𝕜 M) := ⟨of_FG Module.Finite.fg_top⟩

instance : OrderBot (PolyhedralCone 𝕜 M) := ⟨sorry⟩
instance : OrderTop (PolyhedralCone 𝕜 M) := ⟨sorry⟩

instance : Min (PolyhedralCone 𝕜 M) where
  min C D := sorry -- of_FG <| PointedCone.inf_fg C.isFG D.isFG
instance : Max (PolyhedralCone 𝕜 M) where
  max C D := sorry -- of_FG <| PointedCone.sup_fg C.isFG D.isFG
-- NOTE: on cones, ⊔ also acts as Minkowski sum

variable {𝕜 M N : Type*}
variable [Field 𝕜] [LinearOrder 𝕜] [IsStrictOrderedRing 𝕜]
variable [AddCommGroup M] [Module 𝕜 M]
variable [AddCommGroup N] [Module 𝕜 N]
variable {p : M →ₗ[𝕜] N →ₗ[𝕜] 𝕜}

theorem isDualClosed_iff_isDualClosed_lineal (P : PolyhedralCone 𝕜 M) :
  IsDualClosed p P ↔ Submodule.IsDualClosed p (lineal P) := by sorry



def of_CoFG {C : PointedCone 𝕜 N} (hC : C.CoFG p) : PolyhedralCone 𝕜 N
    := ⟨C, by sorry, by sorry⟩

variable (p) in
def dual (C : PolyhedralCone 𝕜 M) : PolyhedralCone 𝕜 N
  := sorry -- of_FG (PointedCone.dual_fg p C.isFG)

def dual_of_fg (C : PointedCone 𝕜 M) (hC : C.FG) : PolyhedralCone 𝕜 N
  := sorry -- dual p (of_FG hC)

def dual_of_finset (s : Finset M) : PolyhedralCone 𝕜 N
  := sorry -- dual p (of_FG <| Submodule.fg_span s.finite_toSet)

def dual_of_finite (S : Set M) (hS : S.Finite) : PolyhedralCone 𝕜 N
  := sorry -- dual p (of_FG <| Submodule.fg_span hS)

variable [Module.Finite 𝕜 N]
variable {p : M →ₗ[𝕜] N →ₗ[𝕜] 𝕜} [p.IsPerfPair]

-- probably needs assumptions, such as perfect pairing maybe?
lemma dual_dual_flip (C : PolyhedralCone 𝕜 N) : dual p (dual p.flip C) = C := by
  sorry
lemma dual_flip_dual (C : PolyhedralCone 𝕜 M) : dual p.flip (dual p C) = C := by
  sorry

section Map

variable {𝕜 : Type*} [Semiring 𝕜] [PartialOrder 𝕜] [IsOrderedRing 𝕜]
variable {M N M' N' : Type*}
  [AddCommMonoid M] [Module 𝕜 M]
  -- [AddCommGroup N] [Module 𝕜 N]
  [AddCommMonoid M'] [Module 𝕜 M'] [Module.Finite 𝕜 M']
  -- [AddCommGroup N'] [Module 𝕜 N'] [Module.Finite 𝕜 N']

variable (f : M →ₗ[𝕜] M')

theorem _root_.Submodule.FG.comap {S : Submodule 𝕜 M'} (hs : S.FG) : (S.comap f).FG := by
  sorry

variable {𝕜 : Type*} [Field 𝕜] [LinearOrder 𝕜] [IsStrictOrderedRing 𝕜]
variable {M N M' N' : Type*}
  [AddCommGroup M] [Module 𝕜 M]
  -- [AddCommGroup N] [Module 𝕜 N]
  [AddCommGroup M'] [Module 𝕜 M'] [Module.Finite 𝕜 M']
  -- [AddCommGroup N'] [Module 𝕜 N'] [Module.Finite 𝕜 N']

variable (f : M →ₗ[𝕜] M')

def map (C : PolyhedralCone 𝕜 M) : PolyhedralCone 𝕜 M'
  := of_FG <| Submodule.FG.map (f.restrictScalars _) C.isFG

local notation3 "𝕜≥0" => {c : 𝕜 // 0 ≤ c}

def comap (C : PolyhedralCone 𝕜 M') : PolyhedralCone 𝕜 M
  := of_FG <| Submodule.FG.comap (f.restrictScalars _) C.isFG

variable [Module.Finite 𝕜 M]

lemma map_dual (C : PolyhedralCone 𝕜 M) :
    dual (Dual.eval 𝕜 M') (map f C) = comap f.dualMap (dual (Dual.eval 𝕜 M) C) := by
  sorry -- ext x; simp

instance : Neg (PolyhedralCone 𝕜 M) where
  neg C := of_FG <| Submodule.FG.map (-.id) C.isFG

instance : Coe (Submodule 𝕜 M) (PolyhedralCone 𝕜 M) where
  coe S := of_FG <| PointedCone.ofSubmodule_fg_of_fg
    <| (Submodule.fg_iff_finiteDimensional S).mpr inferInstance


-- /-- A linear subspace is a polyhedral cone -/
-- lemma IsPolyhedral.submodule (S : Submodule 𝕜 M) : (S : PointedCone 𝕜 M).FG
--   := PointedCone.ofSubmodule.FG_of_FG
--     <| (Submodule.fg_iff_finiteDimensional S).mpr inferInstance

end Map

end PolyhedralCone

-- namespace PolyhedralCone

-- variable {R M N : Type*}
--   [CommRing R] [LinearOrder R] [IsStrictOrderedRing R]
--   [AddCommGroup M] [Module R M] [Module.Finite R M] [Projective R M]
--   [AddCommGroup N] [Module R N] -- [Module.Finite 𝕜 M]

-- instance : Bot (PolyhedralCone R M) := ⟨⊥, .bot⟩

-- instance uniqueBot : Unique (⊥ : PolyhedralCone R M) :=
--   inferInstanceAs <| Unique (⊥ : PointedCone R M)

-- instance : Top (PolyhedralCone R M) := ⟨ ⊤, .top ⟩

-- instance : Min (PolyhedralCone R M) where
--   min C C' := ⟨C ⊓ C', C.isPolyhedral.inf C'.isPolyhedral⟩

-- @[simp, norm_cast] lemma coe_inf (C D : PolyhedralCone R M) :
--     (C ⊓ D).toPointedCone = C.toPointedCone ⊓ D.toPointedCone := rfl

-- instance : SemilatticeInf (PolyhedralCone R M) :=
--   PolyhedralCone.toPointedCone_injective.semilatticeInf _ coe_inf

-- -- TODO: add simp lemmas

-- variable {𝕜 M N : Type*}
--   [Field 𝕜] [LinearOrder 𝕜] [IsStrictOrderedRing 𝕜]
--   [AddCommGroup M] [Module 𝕜 M] [Module.Finite 𝕜 M]
--   [AddCommGroup N] [Module 𝕜 N] -- [Module.Finite 𝕜 M]

-- def of_IsPolyhedral {C : PointedCone 𝕜 M} (hC : C.IsPolyhedral) : PolyhedralCone 𝕜 M := ⟨ C, hC ⟩
-- def of_fg {C : PointedCone 𝕜 M} (hC : C.FG) : PolyhedralCone 𝕜 M := of_IsPolyhedral (.of_fg 𝕜 hC)

-- def span {S : Set M} (hfin : S.Finite) : PolyhedralCone 𝕜 M := of_IsPolyhedral (.span hfin)

-- variable (p : M →ₗ[𝕜] N →ₗ[𝕜] 𝕜) [p.IsPerfPair]
-- variable [Module.Finite 𝕜 N]
-- variable {p : M →ₗ[𝕜] N →ₗ[𝕜] 𝕜} [p.IsPerfPair]

-- instance : Max (PolyhedralCone 𝕜 M) where
--   max C C' := ⟨C ⊔ C', C.isPolyhedral.sup C'.isPolyhedral⟩

-- @[simp, norm_cast] lemma coe_sup (C D : PolyhedralCone 𝕜 M) :
--     (C ⊔ D).toPointedCone = C.toPointedCone ⊔ D.toPointedCone := rfl

-- instance : SemilatticeSup (PolyhedralCone 𝕜 M) :=
--   PolyhedralCone.toPointedCone_injective.semilatticeSup _ coe_sup

-- lemma dual_inf {C C' : PolyhedralCone 𝕜 M} : dual p (C ⊓ C') = dual p C ⊔ dual p C' :=
--   sorry

-- lemma dual_sup {C C' : PolyhedralCone 𝕜 M} : dual p (C ⊔ C') = dual p C ⊓ dual p C' :=
--   sorry

-- end PolyhedralCone

-- /- Lattice structure -/

-- namespace PolyhedralCone

-- variable [Field 𝕜] [LinearOrder 𝕜] [IsOrderedRing 𝕜] [AddCommGroup M] [Module 𝕜 M] {s : Set (Dual 𝕜 M)} {w : M}

-- def ofSubmodule (S : Submodule 𝕜 M) : PolyhedralCone 𝕜 M := ⟨ S, .submodule S ⟩

-- instance : Coe (Submodule 𝕜 M) (PolyhedralCone 𝕜 M) := ⟨ .ofSubmodule ⟩

-- instance completeLattice : CompleteLattice (PolyhedralCone 𝕜 M) :=
--   { (inferInstance : OrderTop (PolyhedralCone 𝕜 M)),
--     (inferInstance : OrderBot (PolyhedralCone 𝕜 M)) with
--     sup := fun a b ↦ sInf { x | a ≤ x ∧ b ≤ x }
--     le_sup_left := fun _ _ ↦ le_sInf' fun _ ⟨h, _⟩ ↦ h
--     le_sup_right := fun _ _ ↦ le_sInf' fun _ ⟨_, h⟩ ↦ h
--     sup_le := fun _ _ _ h₁ h₂ ↦ sInf_le' ⟨h₁, h₂⟩
--     inf := (· ⊓ ·)
--     le_inf := fun _ _ _ ↦ Set.subset_inter
--     inf_le_left := fun _ _ ↦ Set.inter_subset_left
--     inf_le_right := fun _ _ ↦ Set.inter_subset_right
--     sSup S := sInf {sm | ∀ s ∈ S, s ≤ sm}
--     le_sSup := fun _ _ hs ↦ le_sInf' fun _ hq ↦ by exact hq _ hs
--     sSup_le := fun _ _ hs ↦ sInf_le' hs
--     le_sInf := fun _ _ ↦ le_sInf'
--     sInf_le := fun _ _ ↦ sInf_le' }

-- end PolyhedralCone
